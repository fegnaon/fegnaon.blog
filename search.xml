<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMU-15-213-datalab</title>
      <link href="/fegnaon.blog/2021/11/20/CMU-15-213-datalab/"/>
      <url>/fegnaon.blog/2021/11/20/CMU-15-213-datalab/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~((~(~x&amp;y))&amp;(~(~y&amp;x)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;<span class="comment">//Tmin的位只有第一个位为1，其他为全为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;<span class="comment">//就可以把最后一位凑出一个1，然后左移31位来填充0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//Tmax加1和~Tmax的值一样，所以他们两个的差为0</span></span><br><span class="line">  <span class="keyword">return</span> (!(((~x) + (~(x+<span class="number">1</span>))+<span class="number">1</span>)))&amp;(!!(x+<span class="number">1</span>));<span class="comment">//但是-1（位全为1）也满足上面的情况，所以要再用-1+1=0的特性来</span></span><br><span class="line">&#125;<span class="comment">//排除-1。求差可以用a-b=a+(~b+1)来表示</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//先构造出一个奇数位全为1，偶数位全为0的数a（即0xAAAAAAAA)</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0xAA</span>;<span class="comment">//然后用x&amp;a来检测x的所有奇数位，并去除偶数位的影响(0&amp;任何数都是0)</span></span><br><span class="line">  a = (a&lt;&lt;<span class="number">8</span>) + a;<span class="comment">//若x奇数位中有0，那么x&amp;a的对应为就会为0，再与a异或时就会为0</span></span><br><span class="line">  a = (a&lt;&lt;<span class="number">16</span>) + a;<span class="comment">//所以若x的奇数位全为1时，(x&amp;a)^a就会是0，然后用！来转换成1，并把其他非零值转换为0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !((x&amp;a)^a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//根据 -a=~a+a  直接得到</span></span><br><span class="line">  <span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//原题可以转化为x-0x30 &gt;= 0和x-0x39 &lt;= 0，先求出两个差值，然后根据符号位的情况判断</span></span><br><span class="line">  <span class="keyword">int</span> a = x + ((~<span class="number">0x30</span>) + <span class="number">1</span>);<span class="comment">//因为大于等于的0的符号位为0，小于0的数的符号位为1，所以把x-0x39&lt;=0等价为x-0x3a&lt;0</span></span><br><span class="line">  <span class="keyword">int</span> b = x + ((~<span class="number">0x3a</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !!(((a&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>)&amp;((b&gt;&gt;<span class="number">31</span>)+<span class="number">2</span>));<span class="comment">//然后用&amp;判断两个不等式是否同时成立，并用!!转换为1或0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;<span class="comment">//把返回值表示为，bool(x)*y + !bool(x) * z来实现判断</span></span><br><span class="line">  <span class="keyword">int</span> a = ((!x) + (~<span class="number">0</span>)) &amp; y;<span class="comment">//x对应的布尔值只可能是0或1</span></span><br><span class="line">  <span class="keyword">int</span> b = ((!!x) + (~<span class="number">0</span>)) &amp; z;<span class="comment">//1乘x可以表示为0xFFFFFFFF&amp;x，即暴露x原来的位</span></span><br><span class="line">                                            <span class="comment">//0乘x可以表示为0x00000000&amp;x，即把所有位设置为0</span></span><br><span class="line">  <span class="keyword">return</span> a+b;<span class="comment">//所以就需要把x为真时转换为0xFFFFFFFF,x为假时转换为0x0000000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//可以分x,y异号和同号两种情况来分别讨论</span></span><br><span class="line">  <span class="keyword">int</span> x_sgn = (x&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;<span class="comment">//若x,y异号，可以直接通过x的符号来判断x是否小于y</span></span><br><span class="line">  <span class="keyword">int</span> y_sgn = (y&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;<span class="comment">//x,y异号时，x大于的0话就肯定大于y了，若x小于零时也肯定小于y</span></span><br><span class="line">  <span class="keyword">int</span> if_sgn_not_same = x_sgn^y_sgn;<span class="comment">//处理完xy异号的情况之后，就可以把原式转换为x-y&lt;=0了(因为同号所以不用考虑溢出了)</span></span><br><span class="line">  <span class="keyword">int</span> result_sgn = if_sgn_not_same &amp; x_sgn;<span class="comment">//x-y&lt;=0可以转换为x-y-1&lt;0，来使确保符号位为1或0</span></span><br><span class="line">  <span class="keyword">int</span> xminusy_sgn = ((x+(~y))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (if_sgn_not_same &amp; (!result_sgn)) + ((!if_sgn_not_same) &amp; !xminusy_sgn);</span><br><span class="line">&#125;<span class="comment">//通过设置if_sgn_not_same为1或0来决定返回值由哪一种情况决定</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//原题可以看作是判断x的位中是否有1存在</span></span><br><span class="line">  <span class="keyword">return</span> (((x^((~x)+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>)&amp;((x&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>);<span class="comment">//用x^((~x)+1)会使从最低位开始数第一个1所在的位及其右边的位全为0</span></span><br><span class="line">    <span class="comment">//因为0对应的1在加1之后都会因为进位而变回0，第一个1对应的0也会被进位回1，异或后就0，其他的位都为1</span></span><br><span class="line">    <span class="comment">//若x为0，那~x在加1之后会溢出变回0，会得到全0，就与其他数字分离出来了</span></span><br><span class="line">&#125;<span class="comment">//以此通过判断最高位是否为1来判断x中是否含有1</span></span><br><span class="line">        <span class="comment">//但是如果x为Tmin,第一个1所在的位的左边没有位了，是个特殊情况，就单独写一块来排除这个情况</span></span><br><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CMU 15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-213 Cprogramminglab</title>
      <link href="/fegnaon.blog/2021/11/18/CMU-15-213-Cprogramminglab/"/>
      <url>/fegnaon.blog/2021/11/18/CMU-15-213-Cprogramminglab/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><h5 id="queue-c"><a href="#queue-c" class="headerlink" title="queue.c"></a>queue.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;harness.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create empty queue.</span></span><br><span class="line"><span class="comment">  Return NULL if could not allocate space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">queue_t</span> *<span class="title">q_new</span><span class="params">()</span><span class="comment">//写这个函数的时候还好，第一次写没有太大问题</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//后面为了其他的操作方便添加了tail和size</span></span><br><span class="line">    <span class="keyword">queue_t</span> *q =  <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">queue_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free all storage used by queue */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_free</span><span class="params">(<span class="keyword">queue_t</span> *q)</span><span class="comment">//这个第一次写的没有问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">list_ele_t</span> *del_ele,*next_ele;</span><br><span class="line">    del_ele = q-&gt;head;</span><br><span class="line">    next_ele = q-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(next_ele)</span><br><span class="line">    &#123; </span><br><span class="line">      next_ele = next_ele-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(del_ele-&gt;value);</span><br><span class="line">      <span class="built_in">free</span>(del_ele);</span><br><span class="line">      del_ele = next_ele;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Attempt to insert element at head of queue.</span></span><br><span class="line"><span class="comment">  Return true if successful.</span></span><br><span class="line"><span class="comment">  Return false if q is NULL or could not allocate space.</span></span><br><span class="line"><span class="comment">  Argument s points to the string to be stored.</span></span><br><span class="line"><span class="comment">  The function must explicitly allocate space and copy the string into it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">q_insert_head</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">char</span> *s)</span><span class="comment">//这个函数折磨了一天...最后7分好长时间都得不到</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (!q)&#123;<span class="comment">//犯错的地方1，最开始把给newh分配内存写在检车q是否为NULL前面了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//而且在检查出q为NULL的分支中没有free为newh分配的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">list_ele_t</span> *newh;</span><br><span class="line">    <span class="keyword">if</span> (!(newh = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">list_ele_t</span>))))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(newh-&gt;value = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>))))&#123;<span class="comment">//犯错的地方2</span></span><br><span class="line">      <span class="built_in">free</span>(newh);<span class="comment">//最开始也没在检查出value为NULL的分支中把newh给free掉</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(newh-&gt;value,s);</span><br><span class="line">    newh-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      q-&gt;head = newh;</span><br><span class="line">      q-&gt;tail = newh;</span><br><span class="line">      q-&gt;size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      newh-&gt;next = q-&gt;head;</span><br><span class="line">      q-&gt;head = newh;</span><br><span class="line">      q-&gt;size ++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Attempt to insert element at tail of queue.</span></span><br><span class="line"><span class="comment">  Return true if successful.</span></span><br><span class="line"><span class="comment">  Return false if q is NULL or could not allocate space.</span></span><br><span class="line"><span class="comment">  Argument s points to the string to be stored.</span></span><br><span class="line"><span class="comment">  The function must explicitly allocate space and copy the string into it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">q_insert_tail</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">char</span> *s)</span><span class="comment">//这个函数的犯的错误和上面那个一样，都是在2个if里忘记free掉newt</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!q)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">list_ele_t</span> *newt;</span><br><span class="line">    <span class="keyword">if</span> (!(newt = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">list_ele_t</span>))))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(newt-&gt;value = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>))))&#123;</span><br><span class="line">      <span class="built_in">free</span>(newt);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(newt-&gt;value,s);</span><br><span class="line">    newt-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      q-&gt;head = newt;</span><br><span class="line">      q-&gt;tail = newt;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;tail-&gt;next = newt;</span><br><span class="line">    q-&gt;tail = newt;</span><br><span class="line">    q-&gt;size ++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Attempt to remove element from head of queue.</span></span><br><span class="line"><span class="comment">  Return true if successful.</span></span><br><span class="line"><span class="comment">  Return false if queue is NULL or empty.</span></span><br><span class="line"><span class="comment">  If sp is non-NULL and an element is removed, copy the removed string to *sp</span></span><br><span class="line"><span class="comment">  (up to a maximum of bufsize-1 characters, plus a null terminator.)</span></span><br><span class="line"><span class="comment">  The space used by the list element and the string should be freed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">q_remove_head</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">char</span> *sp, <span class="keyword">size_t</span> bufsize)</span><span class="comment">//这个函数中犯了个错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span> || q-&gt;head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">list_ele_t</span> *rm_ele;</span><br><span class="line">    rm_ele = q-&gt;head;</span><br><span class="line"></span><br><span class="line">    q-&gt;head = q-&gt;head-&gt;next;</span><br><span class="line">    q-&gt;size --;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      q-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sp)&#123;<span class="comment">//犯错的地方</span></span><br><span class="line">      <span class="built_in">strncpy</span>(sp,rm_ele-&gt;value,bufsize<span class="number">-1</span>);<span class="comment">//对strncpy()的功能不熟。该函数不会在字符串后自动加上空字符</span></span><br><span class="line">      sp[bufsize<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//所以需要在字符串的末尾手动加上一个空字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(rm_ele-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(rm_ele);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Return number of elements in queue.</span></span><br><span class="line"><span class="comment">  Return 0 if q is NULL or empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">q_size</span><span class="params">(<span class="keyword">queue_t</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!q)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Reverse elements in queue</span></span><br><span class="line"><span class="comment">  No effect if q is NULL or empty</span></span><br><span class="line"><span class="comment">  This function should not allocate or free any list elements</span></span><br><span class="line"><span class="comment">  (e.g., by calling q_insert_head, q_insert_tail, or q_remove_head).</span></span><br><span class="line"><span class="comment">  It should rearrange the existing ones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_reverse</span><span class="params">(<span class="keyword">queue_t</span> *q)</span><span class="comment">//一开始直接读错题。。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span> || q-&gt;head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size == <span class="number">1</span>)&#123;<span class="comment">//错误的地方1，第一次改动之后也没考虑到当节点数为1时，无法用节点数&gt;=2时的方法来操作</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;tail = q-&gt;head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">list_ele_t</span> *add_ele;</span><br><span class="line">    <span class="keyword">list_ele_t</span> *nhead,*lnhead;</span><br><span class="line"></span><br><span class="line">    lnhead = q-&gt;head;</span><br><span class="line">    </span><br><span class="line">    add_ele = q-&gt;head-&gt;next;</span><br><span class="line">    nhead = add_ele;</span><br><span class="line">    </span><br><span class="line">    lnhead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(add_ele-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">      nhead = add_ele;</span><br><span class="line">      add_ele = add_ele-&gt;next;</span><br><span class="line"></span><br><span class="line">      nhead-&gt;next = lnhead;</span><br><span class="line">      lnhead = nhead;</span><br><span class="line">    &#125;</span><br><span class="line">    nhead = add_ele;</span><br><span class="line">    nhead-&gt;next = lnhead;</span><br><span class="line"></span><br><span class="line">    q-&gt;head = nhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="queue-h"><a href="#queue-h" class="headerlink" title="queue.h"></a>queue.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************** Data structure declarations ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Linked list element (You shouldn&#x27;t need to change this) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Pointer to array holding string.</span></span><br><span class="line"><span class="comment">       This array needs to be explicitly allocated and freed */</span></span><br><span class="line">    <span class="keyword">char</span> *value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">list_ele_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Queue structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_ele_t</span> *head;  <span class="comment">/* Linked list of elements */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      You will need to add more fields to this structure</span></span><br><span class="line"><span class="comment">      to efficiently implement q_size and q_insert_tail</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">list_ele_t</span> *tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; <span class="keyword">queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************** Operations on queue ************************/</span></span><br><span class="line"><span class="function"><span class="keyword">queue_t</span> *<span class="title">q_new</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_free</span><span class="params">(<span class="keyword">queue_t</span> *q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">q_insert_head</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">q_insert_tail</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">q_remove_head</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">char</span> *sp, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">q_size</span><span class="params">(<span class="keyword">queue_t</span> *q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_reverse</span><span class="params">(<span class="keyword">queue_t</span> *q)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---     TOTAL           100/100</span></span><br></pre></td></tr></table></figure><h1 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h1><h5 id="出来混总是要还的"><a href="#出来混总是要还的" class="headerlink" title="出来混总是要还的"></a>出来混总是要还的</h5><p>malloc来的内存也总是要free的</p><p>这个lab错的最多的地方就是忘记free</p><p>每一个malloc() 都必须注意有无对应的free()</p><h5 id="考虑要全面"><a href="#考虑要全面" class="headerlink" title="考虑要全面"></a>考虑要全面</h5><p>就像高中数学的分类讨论把。。</p><p>漏了某种情况就是错，就扣分</p><p>想好写法了之后不要急着开始写，要想清楚是否考虑到了所有可能的情况</p>]]></content>
      
      
      
        <tags>
            
            <tag> CMU 15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，函数和指针以及其他一些东西</title>
      <link href="/fegnaon.blog/2021/11/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/"/>
      <url>/fegnaon.blog/2021/11/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2><p>和各种数据类型的变量一样，函数也存储在内存中，所以函数也有地址，就可以用指针来指向函数所在的地址，这种指针就是指向函数的指针，函数名其实就是指向该函数的一个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义这样一个函数之后</span></span><br><span class="line">sum就是一个指向该函数的指针，sum的类型是一个地址</span><br><span class="line">sum(arg1,arg2)则表示调用函数，sum(arg1,arg2)的类型是函数返回值的类型</span><br></pre></td></tr></table></figure><p>同时，和其他的数据类型一样，指向函数的指针也有对应的数组、指向它的指针</p><h3 id="声明指向函数的指针"><a href="#声明指向函数的指针" class="headerlink" title="声明指向函数的指针"></a>声明指向函数的指针</h3><p>指针对类型的要求比较严格，声明指向函数的指针时也要使用正确的类型</p><p>声明一个指向特定类型函数的指针时，可以把函数原型中的函数名替换为括号括起来的*加指针名，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pt)(<span class="keyword">int</span> a,<span class="keyword">int</span> b);</span><br></pre></td></tr></table></figure><p>就声明了一个名为pt的指向一个接收两个int参数并且返回值类型为int的函数，这时就可以让pt指向sum() 函数</p><p>如果指向函数的指针被赋了类型不对应的函数的地址，编译时可能会发出警告</p><p>因为声明指针类型时只需要指出类型，形参的标识符可以不写，比如上面的声明其实可以写成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pt)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h3 id="使用指针访问函数"><a href="#使用指针访问函数" class="headerlink" title="使用指针访问函数"></a>使用指针访问函数</h3><p>当有一个指向函数的指针时，就可以通过该指针来访问函数，有以下两种方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pt)(<span class="keyword">int</span>,<span class="keyword">int</span>) = sum;</span><br><span class="line"></span><br><span class="line">(*pt)(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//第一种，pt指向sum() 函数，那(*pt)(1，2)就相当于sum(1,2) 函数</span></span><br><span class="line">pt(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//pt和sum都是函数的地址，pt和sum就等价，所以pt(1,2)就相当于sum(1,2)</span></span><br></pre></td></tr></table></figure><h3 id="atexit-和qsort-函数"><a href="#atexit-和qsort-函数" class="headerlink" title="atexit() 和qsort() 函数"></a>atexit() 和qsort() 函数</h3><p>指向函数的指针常用作函数的参数，比如这两个函数</p><h4 id="atexit-函数"><a href="#atexit-函数" class="headerlink" title="atexit() 函数"></a>atexit() 函数</h4><p>当程序从main() 返回系统时，会自动调用exit() 函数，C语言可以指定在执行exit() 时调用的特定函数，使用atexit() 函数注册需要在exit() 执行时调用的函数</p><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的参数就是一个指向函数的指针，可以直接使用函数名也可以另外定义指针</p><p>该函数会将参数指向的函数添加到执行exit() 时调用的函数的列表中（执行顺序与添加顺序相反），该列表至少能容纳32个函数</p><h4 id="qsort-函数"><a href="#qsort-函数" class="headerlink" title="qsort() 函数"></a>qsort() 函数</h4><p>该函数用于将数组排序</p><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size,<span class="keyword">int</span> (*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的形参中也有一个指向接受2个指针返回一个int的函数的指针</p><p>第一个参数是指向待排序数组的首字符的指针，第二个参数是待排序的项的数量，第三个参数是待排序的每个元素的大小，第四个参数是用于比较的函数</p><p>第四个参数指向的函数的返回值应该在第一个参数大于第二个参数时返回整数，两个参数相等时返回0，第一个参数小于第二个参数时返回负数</p><p>qsort() 会将第一个参数指向的数组从小到大排序</p><h2 id="泛型选择表达式"><a href="#泛型选择表达式" class="headerlink" title="泛型选择表达式"></a>泛型选择表达式</h2><p>C11新增了一种表达式，叫做泛型选择表达式，会根据表达式中的表达式的类型选择一个值作为整个泛型选择表达式的值，格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Generic(expression, type1:a , type2:b , ... , <span class="keyword">default</span>:c)</span><br></pre></td></tr></table></figure><p>程序会根据expression表达式的值的类型，找到后面对应的类型，然后整个表达式就为对应的类型后面的：后面的值，如果没有找到对应的类型，就会把default：后面的值作为整个表达式的值，泛型选择表达式的值可以任意数据类型的值</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>通常，函数调用的过程包括建立调用、传递参数、跳转到函数代码并返回，因此函数调用都有一定的开销。</p><p>使用类函数宏使代码内联可以避免这样的开销，此外，C还提供另一种方法：内联函数</p><p>C标准中对内联函数的描述是：“把函数变成内联函数意味着尽可能快的调用该函数，其具体效果由实现定义”，因此，把函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。</p><h4 id="定义内联函数"><a href="#定义内联函数" class="headerlink" title="定义内联函数"></a>定义内联函数</h4><p>标准规定具有内部链接的函数可以成为内联函数，内联函数的定义与调用该函数的代码必须在同一个源 文件中</p><p>定义内联函数有多种方法，最简单的方法是使用函数说明符inline和存储类别说明符static，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Noreturn函数说明符"><a href="#Noreturn函数说明符" class="headerlink" title="_Noreturn函数说明符"></a>_Noreturn函数说明符</h2><p>_Noreturn是C的第二个函数说明符，表明调用完成后函数不返回主调函数，比如exit() 函数</p><p>这个函数说明符的目的是告诉用户以免滥用该函数，同时通知编译器可优化一些代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，C预处理器</title>
      <link href="/fegnaon.blog/2021/11/16/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8CC%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/fegnaon.blog/2021/11/16/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8CC%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在正式编译之前，C预处理器会根据源代码中的预处理器指令处理源代码。基本上它的工作是把一些文本替换为另一些文本。</p><h2 id="预处理之前"><a href="#预处理之前" class="headerlink" title="预处理之前"></a>预处理之前</h2><p>在进行预处理之前，编译器会先对代码进行一些翻译处理</p><p>首先，编译器会源代码中出现的字符映射到源字符集</p><p>然后，编译器会定位每个反斜杠（\）后面跟着换行（不是换行符\n）的地方然后删除他们，也就是说，会把多个物理行转换成一个逻辑行，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;hello\         //3个物理行</span></span><br><span class="line"><span class="string"> world\</span></span><br><span class="line"><span class="string"> &quot;</span>);</span><br><span class="line">       </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;hello world&quot;</span>);  <span class="comment">//上面的三行会被转换为这样1行逻辑行</span></span><br></pre></td></tr></table></figure><p>最后，编译器把文本划分成预处理记号序列、空白序列和注释序列。编译器将用一个空格字符替换每一条注释，而且，实现可以用一个空格替换所有的空白字符序列（不包括\n）</p><p>这时，程序已经准备好进入预处理阶段，预处理器查找一行从#开始到第一个换行符结束（一个逻辑行）的预处理指令</p><h2 id="define-定义常量"><a href="#define-定义常量" class="headerlink" title="#define 定义常量"></a>#define 定义常量</h2><p>#define预处理器指令用于定义宏，由以下3部分组成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>         PAI                 3.14159</span></span><br><span class="line"><span class="comment">//预处理器指令    选定的缩写（也称为宏）  替换体（或称替换列表）</span></span><br></pre></td></tr></table></figure><p>预处理器在代码中找到宏之后，就会把宏替换为对于的替换体（这个过程被称为宏展开）</p><p>如果替换体中还有其他的宏，预处理器会继续替换这些宏</p><p>双引号中的宏是个例外，双引号(“ ”）中的宏不会被替换</p><h3 id="重定义常量"><a href="#重定义常量" class="headerlink" title="重定义常量"></a>重定义常量</h3><p>如果已经用#define定义了一个宏，用#define再次定义该宏的过程称为重定义常量</p><p>只有新定义与旧定义完全相同时才允许重定义</p><h3 id="类函数宏"><a href="#类函数宏" class="headerlink" title="类函数宏"></a>类函数宏</h3><p>上面的不带参数的宏称为类对象宏</p><p>在#define中使用参数可以创建外形和作用与函数类似的类函数宏，在宏后面加上括号括起来的参数列表来创建类函数宏，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x+y</span></span><br></pre></td></tr></table></figure><p>预处理器在把宏替换为替换体时，会将替换体中形式参数的位置替换为输入的实际参数，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">//宏</span></span><br><span class="line"><span class="number">1</span>+<span class="number">2</span><span class="comment">//预处理后</span></span><br></pre></td></tr></table></figure><p>要注意，宏只是单纯的替换文本，不会进行计算，所以最好给替换体加上必要的括号来保证替换后能正确的运算，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> * ADD(<span class="number">1</span>,<span class="number">2</span>) 替换之后是 <span class="number">5</span> *<span class="number">1</span>+<span class="number">2</span> 算出来是<span class="number">7</span>而不是<span class="number">15</span></span><br><span class="line">所以应该这样定义宏</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) (x+y)</span></span><br><span class="line">这样宏就被替换为 <span class="number">5</span> * (<span class="number">1</span>+<span class="number">2</span>) 就能得到想要的东西</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="#运算符"></a>#运算符</h4><p>替换体中的双引号中的内容将被视为普通文本，其中的形参不会被看做形参</p><p>如果想在替换体中的字符串中使用参数，可以用把参数写为双引号括起来的#加形参名，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRT(x) printf(<span class="meta-string">&quot;%s&quot;</span>,<span class="meta-string">&quot;a&quot;</span>#x<span class="meta-string">&quot;c&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>预处理器会将这样的#x替换为双引号括起来的实际参数，然后得到”a””实际参数””c”，根据C语言的字符串串联特性，最终得到”a实际参数c”，这样就得到了想要的结果</p><h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="##运算符"></a>##运算符</h4><p>##运算符有黏合作用，预处理器在替换时会把替换体中##运算符前后的空格和##本身去掉，从而把前后的内容黏合在一起，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> example(a) a       ## 1</span></span><br><span class="line">example(<span class="number">1</span>) 将被替换为 <span class="number">11</span>，而不是<span class="number">1</span>       ## <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是替换体中的双引号中的##不会被视为运算符，而只是两个普通字符</p><h2 id="include-文件包含"><a href="#include-文件包含" class="headerlink" title="#include 文件包含"></a>#include 文件包含</h2><p>预处理器发现#include预处理器指令时，会查看后面的文件名并把#include指令替换为这个文件的内容</p><p>这些头文件中通常包含一些需要放在程序顶部的信息，最常用的内容如下</p><ol><li>  符号常量</li><li>  宏函数</li><li>  函数原型</li><li>  各种自定义数据类型的定义或数据类型的重命名</li></ol><p>文件名有两种表示形式，一种用尖括号（&lt;&gt;）括起来，另一种用双引号括起来，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/b.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>尖括号告诉预处理器在标准系统目录中查找该文件</p><p>双引号告诉预处理器在当前目录（或路径指出的地方）查找该文件，如果没有找到会再从标准系统目录中查找</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>可以使用#ifdef，#ifndef，#else，#if，#elif，#endif来创建条件编译，这些指令可以告诉编译器在什么条件下编译哪些代码</p><h3 id="ifdef，-ifndef，-else，-if"><a href="#ifdef，-ifndef，-else，-if" class="headerlink" title="#ifdef，#ifndef，#else，#if"></a>#ifdef，#ifndef，#else，#if</h3><p>#ifdef和一个标识符组成一条预处理指令，如果标识符已经被定义，就会执行#ifdef到下个#else或#endif之前的所有的指令并编译所有的代码</p><p>#ifndef和#ifdef基本相同，只不过是标识符没有被定义时执行</p><p>#else的作用类似于C语言中的else</p><p>#endif用于标识指令块结束，如果有#else，就必须要有#endif，例子入下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> A</span></span><br><span class="line">    ....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> B</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="if，-elif"><a href="#if，-elif" class="headerlink" title="#if，#elif"></a>#if，#elif</h3><p>#if和#elif要和整形常量表达式一起使用，作用和C语言中的if 和else if差不多</p><p>另外，还有另一种形式 #if defined (XXX) ，这种形式和 #ifdef XXX等价</p><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>C标准规定了一些预定义宏，如下</p><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td>__DATE__</td><td>预处理的日期（格式为”Mmm dd yyyy”的字符串字面量，如”Nov 23 2013”）</td></tr><tr><td>__FILE__</td><td>当前源代码文件名的字符串字面量</td></tr><tr><td>__LINE__</td><td>当前源代码文件中行号的整形常量</td></tr><tr><td>__STDC__</td><td>设置为1，表示实训遵循C标准</td></tr><tr><td>__STDC_HOSTED__</td><td>本机环境设置为1，否则设置为0</td></tr><tr><td>__STDC_VERSION__</td><td>支持C99标准，设置为199901L，支持C11标准，设置为201112L</td></tr><tr><td>__TIME__</td><td>翻译代码的时间（格式为”hh:mm:ss”的字符串字面量）</td></tr></tbody></table><h2 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h2><p>#line预处理器指令可以重置宏__LINE__和__FILE__，语法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">line</span> 100    <span class="comment">//表示将下一行设置为第100行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span> 100 <span class="meta-string">&quot;hello&quot;</span>     <span class="comment">//表示将第一行设置为第100行，并将宏__FILE__设置为hello</span></span></span><br><span class="line"><span class="comment">//不能只重置__FILE__</span></span><br></pre></td></tr></table></figure><h2 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h2><p>#error预处理器指令会让预处理发出一条错误信息（#error这一行的内容，#error 后面可以加信息）并使编译过程中断</p><h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>可以通过命令行参数或者IDE菜单修改编译器的一些设置，使用#pragma预处理器指令可以把编译器指令放入源代码中</p><p>一般编译器都有自己的编译指示集，</p><h4 id="Pragma预处理器运算符"><a href="#Pragma预处理器运算符" class="headerlink" title="_Pragma预处理器运算符"></a>_Pragma预处理器运算符</h4><p>该运算符会把字符串转换成普通的编译指示，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Pragma(<span class="string">&quot;a&quot;</span>) 会被转换为</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> a</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，结构、联合和枚举</title>
      <link href="/fegnaon.blog/2021/11/15/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E7%BB%93%E6%9E%84%E3%80%81%E8%81%94%E5%90%88%E5%92%8C%E6%9E%9A%E4%B8%BE/"/>
      <url>/fegnaon.blog/2021/11/15/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E7%BB%93%E6%9E%84%E3%80%81%E8%81%94%E5%90%88%E5%92%8C%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>结构（struct）是一种自定义的数据类型，它可以包含各种数据类型的成员，比如 int ，double，数组，指针甚至是另一种结构</p><h3 id="声明结构"><a href="#声明结构" class="headerlink" title="声明结构"></a>声明结构</h3><p>使用结构前要声明结构是由那些东西组成的，语句如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用struct关键字来声明结构，在struct后面的是结构的标记，用大括号括起来的是结构的成员的类型和名称，最后要有分号</p><h3 id="定义结构变量"><a href="#定义结构变量" class="headerlink" title="定义结构变量"></a>定义结构变量</h3><p>上面的结构声明创建了一种名为struct Name的新类型，用这个类型名就可以像用 int 一样来定义结构变量，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span> <span class="title">i</span>;</span></span><br></pre></td></tr></table></figure><p>表示创建了一个类型为struct Name的标识符为 i 的变量</p><p>在声明结构时可以同时定义结构变量，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    ...</span><br><span class="line">&#125;i;</span><br></pre></td></tr></table></figure><p>表示在声明了结构的同时也定义了类型为该结构的 i 变量</p><p>声明结构时也可以不写结构标记，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    ...</span><br><span class="line">&#125;i;</span><br></pre></td></tr></table></figure><p>表示定义了有大括号中的成员的 i 变量，但是因为没有标记，就无法再定义新的相同类型的结构了</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>定义结构变量时可以初始化结构变量，只定义而不初始化的话，结构中成员的值是原来内存上的没有意义的值，方法和初始化数组的相似</p><p>比如一个这样的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">long</span> third;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以按顺序来初始化，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> <span class="title">a</span> =</span> &#123;<span class="number">12</span>,<span class="string">&quot;hello&quot;</span>,<span class="number">666</span>&#125;;</span><br></pre></td></tr></table></figure><p>大括号中的值会被依次按顺序赋给结构中的成员，此时first == 12，字符串为”hello”，third为666</p><p>也可以使用点运算符（.）来指定特定的成员赋值，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> <span class="title">a</span> =</span> &#123;.third = <span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure><p>表示 a 中的third成员被赋值25。当对一个结构进行部分初始时，其他的成员会被自动初始化为0</p><p>若指定的成员后面还有值，回想初始化数组时从指定的成员后面开始依次初始化</p><p>成员最终被初始化的值为最后一次初始化时获得的值</p><h3 id="访问结构中的成员"><a href="#访问结构中的成员" class="headerlink" title="访问结构中的成员"></a>访问结构中的成员</h3><p>访问结构中的成员有以下两种方式</p><ol><li><p>直接使用结构的标识符时，可以使用点运算符（或叫成员运算符）（.）加成员的标识符来访问成员，比如</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.first</span><br></pre></td></tr></table></figure><p>  可以直接当做一个单独的int类型的变量来使用</p></li><li><p>当使用指向结构的指针时，可以使用箭头运算符（或叫箭头成员运算符）（-&gt;）加成员的标识符来访问成员，比如</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> *<span class="title">pt</span> =</span> a;</span><br><span class="line">pt-&gt;first</span><br></pre></td></tr></table></figure><p>  可以直接当做一个单独的int类型的变量来使用</p></li></ol><h3 id="复合字面量和结构"><a href="#复合字面量和结构" class="headerlink" title="复合字面量和结构"></a>复合字面量和结构</h3><p>C语言的复合字面量特性可以用于结构</p><p>对于一些只需要临时使用的结构，复合字面量很好用</p><p>语法是小括号括起来的类型加上大括号括起来的初始化列表，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(struct example)&#123;<span class="number">12</span>,<span class="string">&quot;hello&quot;</span>,<span class="number">666</span>&#125;;</span><br></pre></td></tr></table></figure><p>可以用做函数参数，给其他结构赋值或者用一个指向它的指针来保存</p><p>复合字面量如果在所有函数的外面，就具有静态存储期，如果在块内，就具有自动存储期</p><h3 id="可伸缩型数组成员"><a href="#可伸缩型数组成员" class="headerlink" title="可伸缩型数组成员"></a>可伸缩型数组成员</h3><p>当结构的数组成员有以下特征，该成员就是一个可伸缩型数组成员</p><ol><li>  是结构中的最后一个成员</li><li>  方括号中为空</li></ol><p>比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example2</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">char</span> b[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中的b就是一个可伸缩型数组成员</p><p>当定义一个类型为struct example2类型的变量时，该变量的存储空间中不会为b分配空间，只会为其他成员分配空间</p><p>但是当使用指针和malloc() 来创建该类型的结构时，多分配的内存就会作为b的空间，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example2</span> *<span class="title">pt</span> =</span> (struct example2*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct example2)+n*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure><p>就表示为b分配了n个char类型的大小</p><p>如果结构中的结构想有可伸缩型数组成员，该结构中的结构必须是结构的最后一个成员</p><h3 id="结构和文件"><a href="#结构和文件" class="headerlink" title="结构和文件"></a>结构和文件</h3><p>对于一些很大的结构，将每个成员单独保存到文件中或者从文件中单独读取每个成员可能会很麻烦</p><p>可以考虑使用fread() 和fwrite() 来以二进制的形式整个读取或保存，但是要注意，不同的系统或者不同的编译器甚至同一编译器不同的设置都可能会导致二进制形式的不同</p><h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>联合（union）也是一种数据类型，它能在同一存储空间中存储不同的数据类型（不是同时存储）</p><h3 id="声明联合"><a href="#声明联合" class="headerlink" title="声明联合"></a>声明联合</h3><p>声明联合和声明结构类似，不过关键字要用union，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据以上的声明，就创建了一种名为union a的数据类型，该种数据类型既能存储 int 也能存储 double 也能存储 char</p><h3 id="定义联合变量"><a href="#定义联合变量" class="headerlink" title="定义联合变量"></a>定义联合变量</h3><p>定义联合变量和定义结构变量类型，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span> <span class="title">d</span>;</span></span><br></pre></td></tr></table></figure><p>就定义了一个标识符为d的类型为union a的变量</p><p>当定义该变量时，编译器会为d分配足够容纳它占用存储空间的可能的类型的存储空间，比如这里a中最大的类型为double，d的存储空间就是一个double的大小</p><h4 id="初始化联合"><a href="#初始化联合" class="headerlink" title="初始化联合"></a>初始化联合</h4><p>初始化联合有三种方式</p><ol><li><p>  用另一个同类型的联合来初始化</p></li><li><p>用大括号括起来的一个值来初始化，比如</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span> =</span> &#123;<span class="number">88</span>&#125;;</span><br></pre></td></tr></table></figure><p>  该联合中同类型的成员就会被初始化为88（C中数字字面量默认是int类型，88L才是long类型）</p></li><li><p>使用指定初始化器来初始化</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span> =</span> &#123;.b = <span class="number">1.1</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="访问联合"><a href="#访问联合" class="headerlink" title="访问联合"></a>访问联合</h3><p>访问联合两种方式和访问结构的一样</p><p>但是联合在同一时间只能存储一个值，初始化或每次给联合中的某个成员赋值都会覆盖存储空间中原来的值，再访问其他成员时得到的值就没有意义了</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>可以使用枚举类型（enumerated type）声明符号名称表示整型常量</p><p>可以看做是编译阶段（而非预处理阶段）的宏#define</p><p>声明时可以定义一些符号名称（也称为枚举符）来和某个整型常量对于，语句如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">example</span>&#123;</span>a,b,c&#125;;  <span class="comment">//没有指定数时，a,b,c默认情况下为0,1,2</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">example</span>&#123;</span>a,b = <span class="number">10</span>,c&#125;;  <span class="comment">//a为0，b为指定的10，c为从上一个指定的数的开始依次递增到的数，这里为11</span></span><br></pre></td></tr></table></figure><p>在该声明有效的范围内，就可以用a,b,c来表示他们对于的整型常量</p><p>在编译时，实际上是先将枚举符替换为他们对于的整型常量，然后再进一步处理</p><p>在声明枚举类型时，也可以想定义结构变量或联合变量时一样定义变量，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">example</span>&#123;</span>a,b,c&#125;d;</span><br></pre></td></tr></table></figure><p>但是这里d其实是 int 类型</p><h2 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h2><p>可以使用typedef关键字来为数据类型自定义别名</p><p>用法可以看做是定义变量的语句前加上typedef关键字并且不进行初始化，变量名的位置就是为该种数据类型自定义的别名，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> NB;    <span class="comment">//之后NB就可以看做是int的别名</span></span><br></pre></td></tr></table></figure><p>typedef对结构和复杂数组来说很好用，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;NB;              <span class="comment">//NB就是stuct a的别名</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> NB[<span class="number">5</span>];   <span class="comment">//NB就是int [5]，即含有5个int类型的数组的别名</span></span><br></pre></td></tr></table></figure><p>注意：typedef只是为某种数据自定义一个别名，并不是像宏一样在编译前进行替换</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，文件输入/输出</title>
      <link href="/fegnaon.blog/2021/11/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"/>
      <url>/fegnaon.blog/2021/11/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="文件是什么"><a href="#文件是什么" class="headerlink" title="文件是什么"></a>文件是什么</h3><p>文件（file）通常是在磁盘或固态硬盘上的一段已命名的存储区</p><p>对操作系统而言，文件会比较复杂</p><p>而C把文件看作是一系列连续的字符串，每个字节都能被单独读取</p><p>由于不同的环境中的文件的格式可能不同，C语言提供两种文件模式，文本模式和二进制模式</p><h3 id="文本模式和二进制模式"><a href="#文本模式和二进制模式" class="headerlink" title="文本模式和二进制模式"></a>文本模式和二进制模式</h3><h4 id="文本内容和二进制内容"><a href="#文本内容和二进制内容" class="headerlink" title="文本内容和二进制内容"></a>文本内容和二进制内容</h4><p>所有文件的内容在计算机中都以二进制形式（0和1）存储。</p><p>如果文件是用的字符编码表示的文本，该文件就是文本文件，其中包含文本内容。</p><p>如果文件中的二进制值表示的其他的大小（比如机器语言代码，数组，图片或者音乐编码等），该文件就是二进制文件，其中包含二进制内容</p><h4 id="文件的文本模式和二进制模式"><a href="#文件的文本模式和二进制模式" class="headerlink" title="文件的文本模式和二进制模式"></a>文件的文本模式和二进制模式</h4><p>在不同的系统，文本文件的格式并不完全相同，比如在MS-DOS中，/r/n表示换行符，在UNIX中，/n表示换行符</p><p>为了规范文本文件的处理，C语言提供两种访问文件的途径，<strong>二进制模式</strong>和<strong>文本模式</strong></p><p>在文本模式中，C语言把不同格式的内容都转换为UNIX格式</p><p>在二进制模式中，程序能访问文件原始的每个字节，如图</p><p><img src="https://i.loli.net/2021/11/10/GZdfpIk6TiAYyXC.jpg" alt="IMG_20211110_142448.jpg"></p><h3 id="I-O的级别"><a href="#I-O的级别" class="headerlink" title="I/O的级别"></a>I/O的级别</h3><p>除了选择文件的格式，大多数情况下，还可以选择I/O的两个级别（即处理文件访问的两个级别）</p><p>底层I/O（low-level I/O）使用操作系统体提供的基本I/O服务</p><p>标准高级I/O（standard high-level I/O）使用C库的标准包和stdio.h头文件定义，因为无法保证所有操作系统都使用相同的底层I/O模型，C标准建立了可移植的I/O模型</p><h3 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h3><p>C程序会自动打开3个文件，它们被称为<strong>标准输入</strong>（standard input）、<strong>标准输出</strong>（standard output）和<strong>标准错误输出</strong>（standard error output），在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。</p><p>标准输入为程序提供输入，它是getchar() 和scanf() 使用的文件</p><p>程序通常输出到标准输出，它是putchar() 、puts() 和printf() 使用的文件</p><p>可以使用重定向来把其他文件视为标准文件</p><h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p>与底层I/O相比，标准I/O处理可移植之外，还有两个好处</p><p>第一，标准I/O有许多专门的函数简化了处理不同I/O的问题</p><p>第二，输入和输出都是缓冲的。也就是说，一次转移一大块信息而不是一字节信息（通常至少512字节），这极大的提高了数据传输速率</p><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><p>当程序读到文件结束时，用getc() 函数获取一个字符时会返回特殊值EOF</p><h3 id="标准I-O的机理"><a href="#标准I-O的机理" class="headerlink" title="标准I/O的机理"></a>标准I/O的机理</h3><p>使用标准I/O的第一步是调用fopen() 打开文件</p><p>fopen() 函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构</p><p>这个结构通常包含一个指定流中当前位置的文件位置指示器，此外，它还包含错误和文件结尾指示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）</p><p>调用输入函数时，文件中缓冲大小数据块就被拷贝到缓冲区中，缓冲区的大小因实现而异，一般是512字节或是它的倍数</p><p>除了填充缓冲区之外，还要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从0字节开始</p><p>在初始化结构和缓冲区之后，输入函数按要求从缓冲区中读取数据。在它读取数据时，文件位置指示器被设置为指向刚读取字符的下一个字符。由于stdio.h系列的所有输入函数都使用相同的缓冲区，所以调佣任何一个函数都将从上一次函数停止调用的位置开始</p><p>当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。以这种方式，输入函数可以读取文件中的所有内容，直到文件结尾。函数在读取缓冲区的最后一个字符后，把结尾指示器设置为真，于是，下一次被调用的输入函数将返回EOF</p><p>输出函数以类似的方式把数据写入缓冲区，当缓冲区被填满时，数据将被拷贝至文件中</p><h2 id="标准I-O函数"><a href="#标准I-O函数" class="headerlink" title="标准I/O函数"></a>标准I/O函数</h2><p>stdio.h头文件提供了一些标准I/O函数</p><h4 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen() 函数"></a>fopen() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><p>fopen() 函数用于打开文件，第1个参数是待打开的文件的文件名，第2个参数是一个字符串，指明了打开文件的模式</p><p>C库提供了以下模式</p><table><thead><tr><th>模式字符串</th><th>含义</th></tr></thead><tbody><tr><td>“r”</td><td>以读模式打开文件</td></tr><tr><td>“w”</td><td>以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件</td></tr><tr><td>“a”</td><td>以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件</td></tr><tr><td>“r+”</td><td>以更新模式（即可以读写文件）打开文件</td></tr><tr><td>“w+”</td><td>以更新模式打开文件，如果文件存在，则将其长度截为0，如果文件不存在，则创建一个新文件</td></tr><tr><td>“a+”</td><td>以更新模式打开文件，在现有文件的末尾添加内容，如果文件不存在，则创建一个新文件；可以读整个文件，但是只能从末尾添加内容</td></tr><tr><td>“rb”</td><td>二进制模式的”r”</td></tr><tr><td>“wb”</td><td>二进制模式的”w”</td></tr><tr><td>“ab”</td><td>二进制模式的”a”</td></tr><tr><td>“rb+”或”r+b”</td><td>二进制模式的”r+”</td></tr><tr><td>“wb+”或”w+b”</td><td>二进制模式的”w+”</td></tr><tr><td>“ab+”或”a+b”</td><td>二进制模式的”a+”</td></tr></tbody></table><p>程序成功打开文件后，将返回一个文件指针，其它I/O函数就可以通过这个指针指定该文件</p><h5 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h5><p>文件指针的类型是指向FILE的指针，并不指向实际的文件，FILE是一个包含文件信息的数据对象，其中包含了操作文件的I/O函数所用的缓冲区信息（比如缓冲区的位置，缓冲区被填充的程度，操作哪一个文件），FILE是一个C结构（结构以后学）</p><p>stdio.h头文件会把3个文件指针与3个标准文件相关联</p><table><thead><tr><th>标准文件</th><th>文件指针</th><th>通常使用的设备</th></tr></thead><tbody><tr><td>标准输入</td><td>stdin</td><td>键盘</td></tr><tr><td>标准输出</td><td>stdout</td><td>显示屏</td></tr><tr><td>标准错误输出</td><td>stderr</td><td>显示屏</td></tr></tbody></table><h4 id="getc-函数和putc-函数"><a href="#getc-函数和putc-函数" class="headerlink" title="getc() 函数和putc() 函数"></a>getc() 函数和putc() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>getc() 函数和putc() 的作用和getchar() putchar() 的类似，不同的是，使用getc() 和putc() 时要告诉函数使用哪一个文件</p><h4 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose() 函数"></a>fclose() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数用于关闭参数指定的文件，必要时刷新缓冲区</p><p>如果成功关闭，返回0，否则返回EOF</p><p>如果磁盘已满、移动硬盘被移除或出现I/O错误都会导致调用fclose() 函数失败</p><h4 id="sprintf-和scanf-函数"><a href="#sprintf-和scanf-函数" class="headerlink" title="sprintf() 和scanf() 函数"></a>sprintf() 和scanf() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数的作用和printf() scanf() 的类似，不过需要使用第一个参数来指定待处理的文件</p><h4 id="fgets-和fputs-函数"><a href="#fgets-和fputs-函数" class="headerlink" title="fgets() 和fputs() 函数"></a>fgets() 和fputs() 函数</h4><p>见字符串那一篇</p><h4 id="rewind-函数"><a href="#rewind-函数" class="headerlink" title="rewind() 函数"></a>rewind() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数会让程序回到文件开始处</p><h4 id="fseek-函数"><a href="#fseek-函数" class="headerlink" title="fseek() 函数"></a>fseek() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数用于将打开的文件直接移动到任意字节处</p><p>第一个参数是FILE指针，指明带查找的文件</p><p>第二个参数是偏移量，指明从起点处开始要移动的距离，可以为正（前移）或负（后移）或0（保持不动）</p><p>第三个参数是模式，指明起始点，在stdio.h头文件中规定了以下几种表示模式的明示常量</p><table><thead><tr><th>模式</th><th>起始点</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开始处</td></tr><tr><td>SEEK_CUR</td><td>当前位置</td></tr><tr><td>SEEK_END</td><td>文件末尾</td></tr></tbody></table><p>如果正常移动，该函数返回0，如果出现错误（比如移动的距离超出文件的范围），就返回-1</p><h4 id="ftell-函数"><a href="#ftell-函数" class="headerlink" title="ftell() 函数"></a>ftell() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数用于参数指向的文件的当前位置距离距文件开始处的字节数</p><p>如果执行成功，该函数会返回文件的当前位置距离距文件开始处的字节数，如果执行失败，则会返回-1L</p><p>该函数可以和fseek() 函数配合使用，比如计算文件的字节数</p><h4 id="fgetpos-和fsetpos-函数"><a href="#fgetpos-和fsetpos-函数" class="headerlink" title="fgetpos() 和fsetpos() 函数"></a>fgetpos() 和fsetpos() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *stream, <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure><p>ftell() 和fseek() 由于使用long类型来表示字节数，如果文件很大，long的范围可能无法表示全部的字节</p><p>处理大文件时，可以使用fgetpos() 和fsetpos() 函数来处理大文件</p><p>这两个函数不使用long类型的值来表示位置，而是使用fpos_t类型（一种定义在stdio.h头文件中的新类型）</p><p>调用fgetpos()函数时，会把第一个参数指向的文件的当前位置的值以fpos_t类型保存在第二个参数指向的位置上，该值描述了文件当前位置距离文件开头的字节数</p><p>调用fsetpos() 函数时，会将第一个参数指向的文件的位置移到当前位置偏移第二个参数的值后的位置</p><p>如果成功，这两个函数都会返回0，如果失败，则返回非0</p><h4 id="fflush-函数"><a href="#fflush-函数" class="headerlink" title="fflush() 函数"></a>fflush() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数会使输出缓冲区中所有的未写入数据发送到参数指定的输出文件，这个过程称为<strong>刷新缓冲区</strong></p><p>如果参数是空指针，所有的输出缓冲区都会被刷新</p><h4 id="setvbuf-函数"><a href="#setvbuf-函数" class="headerlink" title="setvbuf() 函数"></a>setvbuf() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数创建一个供标准I/O函数替换使用的缓冲区</p><p>需要在打开文件后且未对流进行其他操作之前调用该函数</p><p>第一个参数指向待处理的流，第二个参数指向待使用的存储区，第三个参数指明模式，第四个参数指明缓冲区的大小</p><p>buf应是一个具有一定大小的存储空间，比如一个数组，如果把NULL作为buf的值，该函数会自动分配一个size大小的缓冲区</p><p>mode有如下几种选择</p><table><thead><tr><th>mod</th><th>含义</th></tr></thead><tbody><tr><td>_IOFBF</td><td>完全缓冲（缓冲区满时刷新）</td></tr><tr><td>_IOLBF</td><td>行缓冲（缓冲区满或写入一个换行符时刷新）</td></tr><tr><td>_IONBF</td><td>无缓冲</td></tr></tbody></table><p>如果操作成功，就返回0，如果失败，就返回一个非零值</p><h4 id="fread-和fwrite-函数"><a href="#fread-和fwrite-函数" class="headerlink" title="fread() 和fwrite() 函数"></a>fread() 和fwrite() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb,FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>前面的I/O函数在读取和写入是都是按字符的格式进行的，因此可能会造成精度损失，比如，读取3.333333这样一个浮点数时，只能获取它的字符串形式，不能直接读取一个double，就可能造成误差</p><p>使用fread() 和fwrite() 函数可以以二进制形式处理数据</p><p>第一个参数是待写入数据的地址或待读取数据的地址，第二个参数指明待写入或待读取的一个数据块的大小，第三个参数指明待写入或待读取的数据块的数量，最后一个参数指定待写入或待读取的文件</p><h4 id="feof-和ferror-函数"><a href="#feof-和ferror-函数" class="headerlink" title="feof() 和ferror() 函数"></a>feof() 和ferror() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>如果标准I/O函数返回EOF，通常表明函数已到达文件结尾，但是，当出现错误时，也会返回EOF</p><p>feof() 和ferroe() 函数用于区分这两种情况</p><p>当上一次输入调用检测到文件结尾时，feof() 函数返回一个非零值，否则返回0</p><p>当读或写出现错误，ferror() 函数返回一个非零值，否则返回0</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="exit-函数"><a href="#exit-函数" class="headerlink" title="exit() 函数"></a>exit() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><p>exit() 函数关闭所有打开的文件并结束程序。exit的参数被传递给一些操作系统，以供其他应用程序使用</p><p>用0或EXIT_SUCCESS表明成功结束程序</p><p>用EXIT_FAILUER表明失败结束程序</p><p>在main() 中调用return和exit() 的效果相同，但是爱其他函数中宏，return只会把控制权交给上一级递归，而调用exit() 能结束整个程序</p><p>上述宏和该函数的原型都在stdlib.h头文件中</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，存储类别、链接和内存管理</title>
      <link href="/fegnaon.blog/2021/11/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/fegnaon.blog/2021/11/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h1><p>C语言提供了多种不同的存储类别在内存中存储数据</p><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先理解一些基本概念</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>被存储的数据都占用一定的物理内存，C语言把这样的一块内存称为<strong>对象</strong>。对象可以存储一个或多个值，或未存储实际的值，但他在存储实际的值时一定具有对应的大小</p><p>访问对象，可以通过声明变量来完成，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>该声明在对象中存储了0这个值，并创建了一个名为a的<strong>标识符</strong>，且这个标识符指定了存有0的这个对象</p><p>标识符不是唯一指定对象的方法，，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pt = &amp;a;</span><br></pre></td></tr></table></figure><p>pt是一个指定一个存储有一个地址的对象的标识符，但是*pt并不是一个表示，而是一个表达式，但也能指定一个存有int的对象</p><h4 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h4><p>指定对象的表达式被称为<strong>左值</strong></p><h4 id="可修改的左值"><a href="#可修改的左值" class="headerlink" title="可修改的左值"></a>可修改的左值</h4><p>如果可以用左值修改对象中的值，那该左值就是一个<strong>可修改的左值</strong></p><h4 id="描述对象和标识符"><a href="#描述对象和标识符" class="headerlink" title="描述对象和标识符"></a>描述对象和标识符</h4><p>可以用<strong>存储期</strong>来描述<strong>对象</strong></p><p>用<strong>作用域</strong>和<strong>链接</strong>描述<strong>标识符</strong></p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域描述程序中可访问标识符的区域</p><p>C语言中4种作用域，分别是块作用域、函数作用域、函数原型作用域和文件作用域</p><h5 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h5><p><strong>块</strong>是用一对花括号括起来的代码区域。此外，循环和If语句本身也是一个块，他们的子语句是其字块，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//第一层块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>)<span class="comment">//第二层块</span></span><br><span class="line">    &#123;<span class="comment">//第三层块</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在块中变量具有块作用域，块作用域的变量的可见范围是从定义处到其所在块的末尾</p><p>函数的形式参数虽然在花括号外声明，但他们也属于函数体这个块</p><h5 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h5><p>函数作用域仅用于goto的标签，一个标签即使出现在函数的内层块中，他的作用域也会延伸至整个函数</p><h5 id="函数原型作用域"><a href="#函数原型作用域" class="headerlink" title="函数原型作用域"></a>函数原型作用域</h5><p>函数原型作用域用于函数原型中的形参名，它的范围是从形参定义处到函数原型结束</p><h5 id="文件作用域"><a href="#文件作用域" class="headerlink" title="文件作用域"></a>文件作用域</h5><p>定义在所有函数外面的变量具有文件作用域，从定义处到定义它的文件的末尾都该种变量都可见</p><p>文件作用域变量也称为全局变量</p><h5 id="翻译单元和文件"><a href="#翻译单元和文件" class="headerlink" title="翻译单元和文件"></a>翻译单元和文件</h5><p>C预处理实际上使用包含的头文件中的内容替换#include指令。所以，编译器把源代码文件和所有头文件都看做是一个包含信息的单独的文件，这个文件被称为<strong>翻译单元</strong>，文件作用域变量的可见范围其实是整个翻译单元</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>变量的链接属性指明了它能不能被其他翻译单元所使用</p><p>C语言中有3中链接属性，分别是无连接、内部链接、外部链接</p><h5 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h5><p>具有块作用域、函数作用域和函数原型作用域的变量都是无连接变量，意味着他们只属于定义他们的块或函数或原型私有</p><h5 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h5><p>外部链接变量可以在多文件程序中使用，声明时不加修饰的文件作用域变量就是外部链接</p><h5 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h5><p>内部链接变量只能在一个翻译单元中使用，声明文件作用域变量时使用存储类别说明符static可以表示该变量为内部链接，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//文件作用域，外部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">5</span>;<span class="comment">//文件作用域，内部链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h4><p>存储期描述了对象的生存期</p><p>C对象有4中存储期，分别是静态存储期、线程存储期、自动存储期和动态分配存储期</p><h5 id="静态存储期"><a href="#静态存储期" class="headerlink" title="静态存储期"></a>静态存储期</h5><p>具有静态存储期的对象，在程序的执行期间一直存在</p><p>文件作用域变量具有静态存储期</p><p>块作用域也能具有静态存储期，需要在声明前加上关键字static来创建这样的变量</p><h5 id="线程存储期"><a href="#线程存储期" class="headerlink" title="线程存储期"></a>线程存储期</h5><p>具有线程存储期的对象，从被声明到线程结束一直存在</p><p>具体的以后再学</p><h5 id="自动存储期"><a href="#自动存储期" class="headerlink" title="自动存储期"></a>自动存储期</h5><p>具有自动存储期的对象，从程序进入定义它的块到退出这个块的期间存在</p><p>块作用域的变量通常都具有自动存储期，当程序进入定义这些变量的块时，为这些变量分配内存，当退出这个块时，释放刚才为变量分配的内存</p><p>变长数组稍有不同，它的存储期从定义开始，而不是从进入所在的块开始</p><hr><p>了解基本概念之后，就可以理解存储类别了</p><p>以下是C语言的几种存储类别和对应的属性</p><table><thead><tr><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr><td>自动</td><td>自动存储期</td><td>块作用域</td><td>无</td><td>块中正常声明</td></tr><tr><td>寄存器</td><td>自动存储期</td><td>块作用域</td><td>无</td><td>块中使用register关键字声明</td></tr><tr><td>静态无链接</td><td>静态存储期</td><td>块作用域</td><td>无</td><td>块中使用static关键字声明</td></tr><tr><td>静态内部链接</td><td>静态存储期</td><td>文件作用域</td><td>内部链接</td><td>函数外使用static声明</td></tr><tr><td>静态外部链接</td><td>静态存储期</td><td>文件作用域</td><td>外部链接</td><td>函数外正常声明</td></tr></tbody></table><p>下面是各种存储类别的一些特点</p><h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><ol><li><p>  默认情况下，声明在块或函数头中的任何变量都输入自动变量。</p></li><li><p>  为了更好的表达意图，可以用auto关键字显式的表示该变量是一个自动变量。</p></li><li><p>  如果内层块中声明的自动变量和外层块中声明的自动变量重名，外层块中的自动变量的作用域会被内层快中的隐藏，离开内层块时，外层块的自动变量的作用域会恢复</p></li><li><p>  如果没有显式初始化自动变量，自动变量的值是分配到的内存上原有的值，没有任何意义</p></li></ol><h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><ol><li><p>  寄存器变量储存在最快的可用内存中，不一定在内存中，而有可能被存储在cpu的寄存器中</p></li><li><p>  在声明时使用register关键字即可声明寄存器变量</p></li><li><p>  因为寄存器变量可能存储在寄存器而不是内存中，所以无法获得寄存器变量的地址，不能对寄存器变量使用&amp;运算符</p></li><li><p>  可声明为寄存器变量的数据类型有限，因为寄存器可能没有足够大的空间来存储double或者数组</p></li></ol><h4 id="块作用域的静态变量"><a href="#块作用域的静态变量" class="headerlink" title="块作用域的静态变量"></a>块作用域的静态变量</h4><p>静态变量中的“静态”是指该变量在内存中的原地不动</p><ol><li>  在块中使用static关键字来声明块作用域的静态变量</li><li>  初始化块作用域的静态变量时，只能使用常量表达式来初始化</li><li>  如果未显式初始化块作用域的静态变量，它们会被初始化为0</li><li>  静态变量的声明在程序被载入内存时实际上已经执行完毕，声明语句在代码中的位置只是说明该变量的作用域是在某个块中，而不是在此处声明变量</li><li>  在程序离开这种变量的作用域时，变量在内存上也不会消失，只是不能通过声明的标识符来访问它，但还可以用地址来访问它</li></ol><h4 id="外部链接的静态变量"><a href="#外部链接的静态变量" class="headerlink" title="外部链接的静态变量"></a>外部链接的静态变量</h4><ol><li>  在所有函数外正常声明的变量即为外部链接的静态变量，可以在多文件程序中被所有文件使用</li><li>  初始化外部链接的静态变量时，只能使用常量表达式来初始化</li><li>  如果未显式初始化外部链接的静态变量，它们会被初始化为0</li><li>  在块中如果有与外部链接的静态变量同名的局部变量，外部链接的静态变量在块中会被局部变量隐藏</li></ol><h5 id="5-定义和声明"><a href="#5-定义和声明" class="headerlink" title="5.定义和声明"></a>5.定义和声明</h5><p>想要在一个源代码文件中使用另一个源代码文件中声明的外部链接的静态变量，还必须用extern关键字在该文件中再次声明该变量</p><p>比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在1.c中</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//在2.c中，如果想要使用1.c中声明的a,就需要</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>第一次的声明称为定义式声明（defining declaration），第二次的声明称为引用式声明（referencing declaration）</p><p>关键字extern表明该声明不是定义，会指示编译器去别处查询其定义</p><p>在一定义变量的源代码文件中也可能使用extern多次声明该变量，但是实际没有任何意义，只能表示在某个函数中使用了该变量</p><h4 id="内部链接的静态变量"><a href="#内部链接的静态变量" class="headerlink" title="内部链接的静态变量"></a>内部链接的静态变量</h4><ol><li>  在所有函数外用static关键字声明的变量即为内部链接的静态变量</li><li>  可以在定义该种变量的源代码文件中多次用extern声明，但是没有实际作用</li><li>  初始化内部链接的静态变量时，只能使用常量表达式来初始化</li><li>  如果未显式初始化内部链接的静态变量，它们会被初始化为0</li></ol><h3 id="存储类别和函数"><a href="#存储类别和函数" class="headerlink" title="存储类别和函数"></a>存储类别和函数</h3><p>函数也有存储类别，C语言中的函数一共有三种类别，分别是外部函数，静态函数和内联函数</p><h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>函数在默认情况下即为外部函数</p><p>外部函数可以被其他文件的函数所访问</p><p>用extern关键字声明定义在其他文件中的函数可以表明当前文件中使用的函数被定义在别处</p><h4 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h4><p>静态函数只能用于其定义所在的文件</p><p>定义时使用static关键字可以表明创建的函数是静态函数</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>以后再学</p><h3 id="存储类别的选择"><a href="#存储类别的选择" class="headerlink" title="存储类别的选择"></a>存储类别的选择</h3><p>“按需知道”原则：尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。使用的存储类别绝大多数是自动变量，除自动变量外，其他存储类别的变量也很有用，不过在使用之前要先考虑考虑是否有必要这样做。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>上述的存储类别，都是根据已有的内存管理规则，自动进行存储的</p><p>但是还有更灵活的选择，使用库函数来分配和管理内存，下面的几个函数的原型都在stdlib.h头文件中</p><h4 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc() 函数"></a>malloc() 函数</h4><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数接收一个参数，并找到合适的空闲内存块，字节数为size，然后返回这个的内存块的首字节地址</p><p>内存中还是内存中原有的值，不会进行初始化</p><p>该函数会返回一个指向void的指针，相当于一个通用指针，通常会使用强制类型转换转换该函数的返回值</p><p>malloc() 分配的这样一块内存是匿名，但是可以使用指针保存返回值，然后通过这个指针来访问这块内存</p><p>如果malloc() 分配内存失败了，就会返回一个空指针</p><h4 id="calloc-函数"><a href="#calloc-函数" class="headerlink" title="calloc() 函数"></a>calloc() 函数</h4><p>分配内存还可以使用calloc() 函数，函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是存储单元的数量，第二个参数是存储单元的大小，calloc() 函数会分配一块nmemb * size大小的内存</p><p>calloc() 函数还会将分配到的内存的所有位都初始化为0</p><p>其他的和malloc() 函数相同</p><h4 id="free-函数"><a href="#free-函数" class="headerlink" title="free() 函数"></a>free() 函数</h4><p>使用malloc() 和calloc() 分配的内存的不会被自动回收，如果一直使用这两个函数分配内存，可能就会耗尽所有的内存，这种问题被称为内存泄漏</p><p>使用free() 函数可以避免这种问题，函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数接收malloc() 或calloc () 之前返回的地址，然后释放之前分配的内存，释放掉的内存可以重新被分配</p><h3 id="存储类别和动态内存分配"><a href="#存储类别和动态内存分配" class="headerlink" title="存储类别和动态内存分配"></a>存储类别和动态内存分配</h3><p>程序把它可用的内存分为3部分，一个分供静态变量使用，一部分供自动变量使用，一部分供动态内存分配使用</p><p>静态存储类别所用的内存在编译时确定，只要程序在运行，就可以访问存储在该部分的数据。</p><p>自动存储类别的变量在程序进入定义所在块时存在，在程序离开块时消失。</p><p>动态分配的内存在调用malloc() 函数或者相关函数时存在，在调用free() 时释放。这部分的内存由程序员管理，而不是由一套规则自动管理。</p><p>总而言之，程序把静态对象、自动对象和动态分配的对象存储在不同的区域</p><h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><h4 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h4><p>以const关键字声明的对象，其值不能通过赋值或递增、递减来修改</p><h4 id="volatile限定符"><a href="#volatile限定符" class="headerlink" title="volatile限定符"></a>volatile限定符</h4><p>volatile限定符告知计算机，代理可以改变该变量的值。该限定符设计编译器的优化</p><h4 id="restrict限定符"><a href="#restrict限定符" class="headerlink" title="restrict限定符"></a>restrict限定符</h4><p>restrict限定符允许编译器优化某部分代码</p><p>restrict限定符说明了指针是访问它所指向数据的唯一且初始的方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，字符串</title>
      <link href="/fegnaon.blog/2021/11/04/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/fegnaon.blog/2021/11/04/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是以空字符（\0）结尾的char类型数组</p><h4 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h4><p>用双引号括起来的内容被称为字符串字面量，也叫作字符串常量，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello,world!&quot;</span></span><br></pre></td></tr></table></figure><p>如果多个字符串常量见没有间隔，或只有空格，他们会被自动串联为一个字符串常量，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello,&quot;</span> <span class="string">&quot;world&quot;</span><span class="string">&quot;!&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>和第一个字符串常量一样</p><p>编译器会自动在双引号中的字符最后加上一个空字符</p><p>字符串常量属于静态储存类别，如果使用字符串常量，该字符串只会储存一次，在整个程序的生命期内存在，双引号括起来的字符可以看做是指向这个字符串的指针，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="string">&quot;hello world&quot;</span>) == <span class="string">&#x27;h&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="两种表示形式"><a href="#两种表示形式" class="headerlink" title="两种表示形式"></a>两种表示形式</h4><h5 id="数组表示法"><a href="#数组表示法" class="headerlink" title="数组表示法"></a>数组表示法</h5><p>可以按数组的形式初始化，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">20</span>] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，如果没有最后的空字符，string就是一个字符数组而不是一个字符串。如果没有全部初始化，剩余的元素会被自动初始化为空字符</p><p>以这种形式初始化太过麻烦，也可以用指定的字符串初始化数组，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">20</span>] = <span class="string">&quot;hello,world&quot;</span>;</span><br></pre></td></tr></table></figure><p>数组的大小也可以省略，编译器会自动计算数组的大小，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;hello,world&quot;</span>;</span><br></pre></td></tr></table></figure><p>数组的大小会被自动设置为12（最后还有一个空字符）</p><h5 id="指针表示法"><a href="#指针表示法" class="headerlink" title="指针表示法"></a>指针表示法</h5><p>因为双引号括起来的字符可以看做是指向这个字符串的指针，就可以把这个指针的值赋给别的指针，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = <span class="string">&quot;hello,world&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="两种表示法的区别"><a href="#两种表示法的区别" class="headerlink" title="两种表示法的区别"></a>两种表示法的区别</h5><p>创建一个数组表示的字符串时，内存中会分配出一个能容纳所有元素的空间大小，然后将初始化的字符串复制到这个内存空间中</p><p>创建一个指针表示的字符串时，内存中只会分配出一个指针的大小，初始化时只是将这个指针指向初始化的字符串</p><p>所以，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> string1[] = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">char</span> string2[] = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">char</span> *string3 = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">char</span> *string4 = <span class="string">&quot;hello,world&quot;</span></span><br></pre></td></tr></table></figure><p>string1和string2是两个独立的字符串，string3和string4是指向同一个字符串的指针</p><p>另外，用数组表示的时，数组名可以看做是一个地址常量，永远指向数组的首元素，不能改变。用指针表示时，指针是第一个变量，可以修改指针的指向，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> ++;</span><br></pre></td></tr></table></figure><p>此时，string指向的字符串就变成了”ello,world”</p><p>因为数组是复制了一个副本，所以需要改变字符串时，最好使用数组表示法</p><p>用指针改变字符串常量的行为是未定义的，可能会出错，所以使用指针表示法时，可以使用const关键字，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span> = <span class="string">&quot;hello,world&quot;</span></span><br></pre></td></tr></table></figure><p>如果并不需要改变字符串（比如给字符串排序时），使用的指针的效率更高，因为不需要复制整个字符串，只需要改变指针的指向</p><h4 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h4><p>C库提供了许多用于读取字符串的函数，如 gets() ，fgets() 和 scanf()</p><h5 id="gets-函数"><a href="#gets-函数" class="headerlink" title="gets() 函数"></a>gets() 函数</h5><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>gets() 函数会一直读取字符串，直到遇到换行符，然后会将最后的换行符替换为空字符，并把得到的字符串赋值给s</p><p>但是 gets() 函数并不能检查输入的字符串的长度，如果s装不下这个字符串，就会导致缓冲区溢出（即多余的字符超出了指定的目标空间），可能会导致一些问题</p><p>因此建议不要使用 gets() 函数，C11标准中 gets() 函数已经被废除</p><h5 id="fgets-函数"><a href="#fgets-函数" class="headerlink" title="fgets() 函数"></a>fgets() 函数</h5><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>fgets() 函数会一直从stream读取字符串，直到遇到换行符，或者读入了size-1个字符，然后把得到的字符串赋值给s</p><p>与 gets() 不同，fgets() 不会把换行符替换为空字符，而是在所有字符的末尾加上一个空字符</p><p>如果想读入从键盘输入的字符串，用stdin（标准输入）作为第三个参数</p><p>fgets() 函数会返回第一个参数，如果读到文件末尾，会返回一个空指针（可以用0或者NULL代替）</p><h5 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf() 函数"></a>scanf() 函数</h5><p>可以使用%s来读取字符串，但是scanf() 更像是“获取单词”的函数，字符串读取会在遇到空字符结束或读取到了转换说明的长度，所以scanf() 函数常用语读取并转换混合数据类型，或者读取某种标准形式</p><p>scanf() 函数也可能导致缓冲区溢出，但是可以使用转换说明来限制读取的长度</p><h4 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h4><p>C库提供了许多用于输出字符串的函数，比如puts() , fputs() , printf()</p><h5 id="puts-函数"><a href="#puts-函数" class="headerlink" title="puts() 函数"></a>puts() 函数</h5><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>puts() 函数会输出s指向的地址的中的字符串，输出会在遇到空字符时停止，并自动在其末尾添加一个换行符（如果用fgets() 读入，用puts() 输出，输出的末尾会有两个换行符）</p><p>该函数会返回输出的字符串的长度（包括空字符），如果发生错误会返回EOF</p><h5 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs() 函数"></a>fputs() 函数</h5><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>fputs() 的第二个参数指明s会输出到的文件，如果要打印在显示器上，可以用stdout（标准输出）作为第二个参数</p><p>与 puts() 函数不同，fputs() 不会在输出中添加换行符</p><p>该函数如果成功输入，返回 0，否则返回EOF</p><h5 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf() 函数"></a>printf() 函数</h5><p>printf() 函数也不会在字符串末尾加上换行符，而且printf() 函数在计算机中执行的时间也更长</p><p>但是他可以格式化不同的数据类型，也能使用各种转换说明</p><h4 id="自定义的输入-输出函数"><a href="#自定义的输入-输出函数" class="headerlink" title="自定义的输入/输出函数"></a>自定义的输入/输出函数</h4><p>可以根据需要，在上述几种函数和getchar()，putchar()的基础上，自定义输入/输出函数。</p><p>比如即想能够限制读入的字符串的长度，又不想保存最后的换行符，可以自定义以下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mygets</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fgets(s,size,<span class="built_in">stdin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(s[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能获得想要的功能，并且该函数可以自动丢弃缓冲区中多余的字符（输入都是先输入到缓冲区中，按下回车后程序再从缓冲区中读取数据，如果有部分数据没有被读取，他们会一直留在缓冲区中，在程序下次读取缓冲区时会被继续读取）</p><p>如果需要一个puts() 但不想再末尾添加换行符的函数，可以自定义以下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(*<span class="built_in">string</span>)</span><br><span class="line">        <span class="built_in">string</span> ++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>C库提供了许多用于处理字符串的函数，其中大部分函数的函数原型，都在string.h头文件中，比如strlen() , strcat() ,strcmp()等</p><h5 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen()函数"></a>strlen()函数</h5><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>strlen() 函数会返回 s 指向的字符串的占据的字节数（不包括空字符占据的），比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(<span class="string">&quot;Hello,world!&quot;</span>); <span class="comment">//会返回12</span></span><br><span class="line"><span class="built_in">strlen</span>(<span class="string">&quot;你好&quot;</span>); <span class="comment">//会返回6(GBK编码下)</span></span><br></pre></td></tr></table></figure><h5 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat() 函数"></a>strcat() 函数</h5><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>strcat() 用于将两个字符串拼接在一起，该函数接收两个字符串，然后把第二个字符串的内容拼接到第一个字符串的末尾，并用得到的新字符串替换第一个字符串，</p><p>该函数返回新字符串的地址，即第一个参数</p><h5 id="strncat-函数"><a href="#strncat-函数" class="headerlink" title="strncat() 函数"></a>strncat() 函数</h5><p>strcat() 函数无法检测第一个参数指向的存储空间能否容纳下新的字符串，有可能因为溢出而导致错位。可以使用strncat() 函数避免这情况</p><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>前两个参数的作用和strcat() 函数的一样，第三个参数执行了最大添加字符数，指明了在第一个字符串后最多能添加的字符数</p><h5 id="strcmp-函数"><a href="#strcmp-函数" class="headerlink" title="strcmp() 函数"></a>strcmp() 函数</h5><p>如果想把两个字符串作比较，用==运算符是不行的，因为无论是数组表示还是指针表示都是一个地址，地址是不会相等的</p><p>想比较两个字符串的内容是否相同，可以使用strcmp() 函数</p><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数会比较两个字符串第一个空字符之前的内容。该函数会先比较两个字符串的第一个字符，然后比较两个字符的差值（第一个字符串的字符对应的值减去第二个字符串的字符对应的值），比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>); <span class="comment">//会返回-1</span></span><br></pre></td></tr></table></figure><p>如果差值为 0（意味着两个字符一样），就比较下一个字符，如果不为0（就返回这个差值），如果一直为0就一直到比较到空字符然后返回0</p><h5 id="strncmp-函数"><a href="#strncmp-函数" class="headerlink" title="strncmp() 函数"></a>strncmp() 函数</h5><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>比strcmp() 函数多了第三个参数，该参数指明比较的最多字符数，表示strncmp() 只会比较两个字符串的前n个字符</p><p>其他的与strcmp() 函数相同</p><h5 id="strcpy-函数"><a href="#strcpy-函数" class="headerlink" title="strcpy() 函数"></a>strcpy() 函数</h5><p>与==运算符一样，因为表示字符串的实际是一个地址，用=运算符也无法直接将字符串复制，就需要用strcpy() 函数</p><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数会第二个参数指向的字符串复制到第一个参数指向的字符串。</p><p>复制出来的字符串被称为目标字符串，最初的字符串被称为源字符串</p><h5 id="strncpy-函数"><a href="#strncpy-函数" class="headerlink" title="strncpy() 函数"></a>strncpy() 函数</h5><p>strcpy() 函数也无法检测第一个字符串指向的地方能否容纳源字符串的副本，有可能因为溢出而导致错误</p><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>第三个参数指明了复制的最大字符数，表示函数最多会把源字符串的前n个字符（空字符不算）复制到目标字符串中，如果源字符串字符串小于n，就会把源字符串中所有的字符复制到目标字符串中</p><h5 id="其他字符串函数"><a href="#其他字符串函数" class="headerlink" title="其他字符串函数"></a>其他字符串函数</h5><p>char *strchr(const char *s, int c);</p><p>用于查找字符c在s中首次出现的位置，并返回这个地址，如果在s中没找到c，就返回空指针</p><p>char *strrchr(const char *s, int c);</p><p>用于查找字符c在s中最后一次出现的位置，并返回这个地址，如果在s中没找到c，就返回空指针</p><p>char *strpbrk(const char *s, const char *accept);</p><p>如果s中含有accept中的任意一个字符，就返回第一个参数，如果没有，就返回空指针</p><p>char *strstr(const char *haystack, const char *needle);</p><p>用于查找第二个字符串在第一个字符串中出现的首位置，并返回这个位置的地址，如果没有找到，就返回空指针</p><h5 id="sprintf-函数"><a href="#sprintf-函数" class="headerlink" title="sprintf() 函数"></a>sprintf() 函数</h5><p>与上面的几个函数不同，sprintf() 函数不在头文件string.h中，而在头文件stdio.h中</p><p>函数原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数与printf() 函数基本相同，不过sprintf() 函数不会吧结果打印在显示器上，而是把结果保存在目标字符串中（第一个参数）</p><h4 id="ctype-h字符函数和字符串"><a href="#ctype-h字符函数和字符串" class="headerlink" title="ctype.h字符函数和字符串"></a>ctype.h字符函数和字符串</h4><p>在ctype.h头文件中有许多用于处理字符函数，就可以利用这些函数编写用于处理字符串的函数</p><p>ctype.h中的函数有</p><table><thead><tr><th>函数名</th><th>如果是下列参数，返回值为真</th></tr></thead><tbody><tr><td>isalnum()</td><td>字母或数字</td></tr><tr><td>isalpha()</td><td>字母</td></tr><tr><td>isblank()</td><td>空白字符</td></tr><tr><td>iscntrl()</td><td>控制字符，如ctrl+B</td></tr><tr><td>isdigit()</td><td>数字</td></tr><tr><td>isgraph()</td><td>除空格之外的任何可打印字符</td></tr><tr><td>islower()</td><td>小写字母</td></tr><tr><td>isprintf()</td><td>可打印字符</td></tr><tr><td>ispunct()</td><td>标点符号（除空格或字母数字字符以外的任何可打印字符</td></tr><tr><td>isspace()</td><td>空白字符</td></tr><tr><td>isupper()</td><td>大写字母</td></tr><tr><td>isxdigit()</td><td>十六进制数字符</td></tr></tbody></table><table><thead><tr><th>函数名</th><th>行为</th></tr></thead><tbody><tr><td>tolower()</td><td>如果参数时大写字符，就返回对应的小写字符，如果参数时小写字符，就返回原参数</td></tr><tr><td>toupper()</td><td>如果参数时小写字符，就返回对应的大写字符，如果参数时大写字符，就返回原参数</td></tr></tbody></table><p>比如，如果需要把一个字符串中所有的小写字母改成大写的，就可以自定义以下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>;i &lt; <span class="built_in">strlen</span>(s);i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>C编译运行main() 没有参数或者有两个参数（某些实现实现允许更多的参数）</p><p>当main()有两个参数时，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数被称为argc，表示参数计数，记录命令行中的字符串数量，系统用空格表示一个字符串的结束和下一个字符串的结尾</p><p>第二个参数被称为argv，表示参数值，是一个指针数组，指针依次指向命令行中的字符串，如一个叫test的文件，运行时输入</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>i am argument</span><br></pre></td></tr></table></figure><p>那么argv[0]指向”test”，argv[1]指向”i”，argv[2]指向”am”，argv[3]指向”argument”</p><h4 id="把字符串转换为数字"><a href="#把字符串转换为数字" class="headerlink" title="把字符串转换为数字"></a>把字符串转换为数字</h4><p>C库提供了一些把字符串转换为数字的函数，下面的函数都在stdlib.h头文件中</p><p>int atoi(const char *nptr);</p><p>把字符串开头的数字转换为int类型并返回</p><p>long atol(const char *nptr);</p><p>把字符串开头的数字转换为long类型并返回</p><p>long long atoll(const char *nptr);</p><p>把字符串开头的数字转换为long long类型并返回</p><p>double atof(const char *nptr);</p><p>把字符串开头的数字转换为double类型并返回</p><p>还有一些更智能的函数</p><p>long int strtol(const char *nptr, char **endptr, int base);</p><p>第一个参数指向待转换的字符串，第二个参数标识输入数字结束的地址，最后一个参数标识以什么进制写入数字</p><p>strtoul()，strtod()，strtoll()，strtof()，strtold()等函数作用于strtol()类似，不过返回值的类型不同</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，数组和指针</title>
      <link href="/fegnaon.blog/2021/11/01/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/"/>
      <url>/fegnaon.blog/2021/11/01/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是由数据类型相同的一系列元素组成的</p><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>声明数组时要告诉编译器数组中元素的数据类型和元素的个数（一个整形常量）（在变量名后面用方括号把数字括起来表示），如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numbers[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>表示声明了一个名为numbers的含有10个数据类型为int的元素的数组</p><h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>创建数组可以对数组进行初始化，用花括号括起来被逗号分隔开的所有元素，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numbers[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p>表示初始化数组为1到10</p><p>如果不初始化数组，数组中的值为内存中本来的值，没有意义。如果初始化数组时只初始化了部分元素，剩余的元素会被初始化为0</p><h5 id="数组在内存中的储存"><a href="#数组在内存中的储存" class="headerlink" title="数组在内存中的储存"></a>数组在内存中的储存</h5><p>数组中的各个元素在内存中是紧密挨在一起的，元素之间没有间隙</p><h5 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h5><p>除了按顺序初始化数组为，还可以指定数组中某个元素进行初始化，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numbers[<span class="number">10</span>] = &#123;[<span class="number">2</span>] = <span class="number">121</span>,<span class="number">32</span>&#125;</span><br></pre></td></tr></table></figure><p>表示将数组的第3个元素（元素的索引从0开始）初始化为121，第4个元素初始化为32</p><p>指定初始化器后面的值将用于初始化指定位置后的元素，可以多次初始化某个元素，元素的值由最后一次初始化决定</p><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>数组不能直接赋给另一个数组，为数组赋值时也不能用初始化时的方法，但是可以通过元素的下标（或叫索引）为数组中的某个元素赋值</p><p>元素的下标从0开始，通过数组名加方括号括起来的下标表示数组中的某一个元素，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers[<span class="number">2</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>表示将数组中的第三个元素赋值为100</p><h5 id="越界"><a href="#越界" class="headerlink" title="越界"></a>越界</h5><p>如果下标超过了数组的范围，程序也能继续运行，但是可能会导致一些错误或使程序崩溃</p><p>数组最大下标的是数组大小减1，为了避免出错，最好在声明数组时使用符号常量来表示数组的大小，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="keyword">int</span> numbers[SIZE];</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>数组中的元素也可以是数组，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numbers[<span class="number">5</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>表示创建了一个含有5个元素的数组，其中每个元素是一个含有10个 int 类型的数组</p><h5 id="多维数组初始化"><a href="#多维数组初始化" class="headerlink" title="多维数组初始化"></a>多维数组初始化</h5><p>再花括号中再使用花括号表示各个数组，如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> numbers[<span class="number">5</span>][<span class="number">10</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">231</span>&#125;,....&#125;</span><br></pre></td></tr></table></figure><p>如果花括号中的值的数量不够，对应的数组中未被初始化的元素会被初始化为0</p><p>如果对某一个数组的赋值有错，其余的数组也不会被受影响</p><p>也可以不使用花括号表示数组中的数组而直接赋值，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numbers[<span class="number">5</span>][<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,...&#125;</span><br></pre></td></tr></table></figure><p>这样就会按顺序给元素赋值，第一个数组满了之后再对第二个数组中的元素赋值</p><h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h4><p>C语言中可以对指针进行一些操作，主要有以下几种</p><ol><li><p>赋值，可以把地址赋给指针</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer = &amp;a  (a为一个变量)   或     pointer = a  (a为一个数组)</span><br></pre></td></tr></table></figure></li><li><p>  解引用，使用*运算符可以访问指针指向的地址上的值</p></li><li><p>  取值，指针也是一个变量，使用&amp;运算符能获得指针本身的地址</p></li><li><p>  指针与整数相加，使用+运算符可以将指针与一个整数相加，指针的值会被加上整数与指针指向的数据类型的存储空间大小的乘积</p></li><li><p>  递增指针，相当于加1</p></li><li><p>  指针与整数相减，使用-运算符可以将指针与一个整数相加，指针的值会被减去整数与指针指向的数据类型的存储空间大小的乘积</p></li><li><p>  递减指针，相当于减</p></li><li><p>  指针求差，通常可以用一个指针的值减一个指针的值除以指针指向的数据类型的大小来查看指针之间有多少个数据</p></li></ol><p>因为指针操作会因指针指向的数据类型的大小不同而不同，所以指针也有数据类型</p><h4 id="指针的兼容性"><a href="#指针的兼容性" class="headerlink" title="指针的兼容性"></a>指针的兼容性</h4><p>指针之间的赋值比其他数据类型的赋值更加严格，只有指向相同数据类型的指针之间才能赋值，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">a = &amp;b;  这句就是有效的</span><br><span class="line">a = &amp;c;  这句就是无效的</span><br></pre></td></tr></table></figure><p>此外，将const指针的值赋给非const指针的行为是未定义的，可能会造成不安全</p><h4 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h4><p>数组名，实际上是一个存有数组首元素的地址的指针，如下面的语句一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers = &amp;numbers[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="数组表示法和指针表示法"><a href="#数组表示法和指针表示法" class="headerlink" title="数组表示法和指针表示法"></a>数组表示法和指针表示法</h4><p>对于数组的某一个元素，有两种等价的不同的表示形式如 *(numbers + 1) 和 numbers[1] 表示数组中的第二个元素</p><p>定义函数的形式参数时，int *a ，int a[] 也是等价的，都代表一个指针</p><h4 id="在函数中使用数组"><a href="#在函数中使用数组" class="headerlink" title="在函数中使用数组"></a>在函数中使用数组</h4><p>因为数组名就是数组首元素的地址，可以用数据类型为指针的形式参数来表示数组，对于数组大小，可以用另一个参数来记录或者用另一个指向数组结尾的指针来记录</p><h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><h5 id="声明时使用"><a href="#声明时使用" class="headerlink" title="声明时使用"></a>声明时使用</h5><p>在声明数组时，使用const关键字表示该数组只读，只能在初始化时改变数组中的元素，之后就只能从数组中索引值而不能改变数组</p><h5 id="指向const的指针"><a href="#指向const的指针" class="headerlink" title="指向const的指针"></a>指向const的指针</h5><p>表示将指向的值声明为const的指针，const写在数据类型前面，这类指针无法改变所指的变量的值，但是可以重新指向别的地址，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br></pre></td></tr></table></figure><p>这个const只代表无法通过这个指针改变所指变量，const和非const的变量都可以被这类指针所指</p><h5 id="const的指针"><a href="#const的指针" class="headerlink" title="const的指针"></a>const的指针</h5><p>表示指针的指向无法改变，但可以改变所指变量的值，const关键字要写在*后面，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure><p>一个指针也可以同时是上面两种指针，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure><p>这样就既不能改变指针的指向，也不能通过指针改变所指变量的值</p><h5 id="形式参数中使用"><a href="#形式参数中使用" class="headerlink" title="形式参数中使用"></a>形式参数中使用</h5><p>因为数组只能通过指针的形式传入函数，调用函数就有可能改变数组，若不想数组在调用函数时被改变，可以在形式参数处使用const关键字，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *,...)</span></span></span><br></pre></td></tr></table></figure><p>这样就表示指针指向了一个const的数组，就无法通过地址来改变数组中的元素了</p><p>所以如果需要通过函数改变数组，就不用加const，如果不希望数组在函数中被改变，就最好加上const关键字</p><h4 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h4><p>多维数组的数组名是一个有特定大小和类型的数组的地址，因此就不能用该数组中的数组中的元素的数据类型的指针来指向多维数组，要用数组首元素的数据类型的指针来指向数组，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pt)[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> numbers[<span class="number">2</span>][<span class="number">5</span>];</span><br><span class="line">pt = numbers;</span><br></pre></td></tr></table></figure><p>第一句表示pt是一个指向含有5个int的数组的指针，numbers的首元素也是一个含有5个int的数组，因此就第3句就是有效的</p><p>因为 [] 的优先级比 * 要高，所以需要用 () 把 * 括起来，不然 int *pt[5] 就会表示一个含有5个指向int的指针的数组</p><p>同样是优先级的问题，使用指向多维数组的指针时要记得加  () ,如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*pt)[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> numbers[<span class="number">2</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">    pt = numbers;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(*(pt+<span class="number">1</span>))[<span class="number">1</span>]); <span class="comment">//不加号括号就得不到想要的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将多维数组作为函数的参数时，形式参数中的指针也要像上述的一样</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h4><p>C99标准新增了变长数组，但是在C11中变长数组只是一个可选特性，不是必须实现的特性</p><p>变长数组指的是在声明数组时可以用整形变量或整形表达式来表示数组的维度和大小，并不指在声明之后可以改变数组的大小</p><h4 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h4><p>字面量是指除符号常量之外的常量，比如int类型的字面量 1 , 232 等，数组也有对应的字面量，就是复合字面量</p><p>写法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> [<span class="number">3</span>])&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>括号加数据类型加元素个数加初始化，因为是匿名的，可以用用指针来保存</p><p>暂时先当做匿名的数组，具体啥情况以后再学</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，函数和指针初见</title>
      <link href="/fegnaon.blog/2021/11/01/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%E5%88%9D%E8%A7%81/"/>
      <url>/fegnaon.blog/2021/11/01/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h4 id="函数是什么"><a href="#函数是什么" class="headerlink" title="函数是什么"></a>函数是什么</h4><p>函数（function）是完成特定任务的独立程序代码单元。</p><h4 id="函数有什么用"><a href="#函数有什么用" class="headerlink" title="函数有什么用"></a>函数有什么用</h4><p>首先，使用函数可以避免重复编写相同的代码，一次编写就可以多次使用</p><p>其次，使用函数可以使代码更加的模块化，便于后期修改完善，也能提高程序的可读性</p><h3 id="最简单函数的创建和使用"><a href="#最简单函数的创建和使用" class="headerlink" title="最简单函数的创建和使用"></a>最简单函数的创建和使用</h3><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello();<span class="comment">//函数调佣</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h5><p>函数原型用于告诉编译器函数的类型，会指明函数的签名（signature）（包括函数返回值的类型，函数参数的数量和类型）</p><p>函数原型由 函数类型 + 函数名 + （ + 参数 + ) + ; 组成</p><p>和数据一样，函数也有类型，比如int，double等，若函数没有返回值，可以用void作为函数的类型（若编译器不能识别void，可以用int代替）。同样，也可以用void表示函数没有参数。</p><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>表明在此处执行函数</p><p>通过 函数名 + 括号 表示调用函数。</p><p>程序运行带函数调用后，会找到被调函数（被调用的函数）的函数定义中的语句开始执行，执行完之后再返回主调函数（调用函数的函数）继续运行</p><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>指明函数要做什么</p><p>实际上，函数不是一定要有函数原型，将函数定义写在函数原型处也有一样的效果</p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>在函数中使用的变量是局部变量，只属于该函数，在程序中其他的地方也可以使用相同名称的变量而不会引起冲突，因为他们是相互独立的不同的变量</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>在第一个示例中，被调函数与主调函数之间没有任何通信，如果想要通过向函数中传入数据来使函数有不同的运行结果，可以使用函数参数</p><p>在函数原型中可以指明函数的参数类型和数量，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> argumenta,<span class="keyword">double</span> argumentb ...)</span></span>;</span><br></pre></td></tr></table></figure><p>要先写参数类型，再写参数的名称（在函数原型中可以省略名称），参数和参数之间用逗号隔开，多余的空格会被忽略</p><p>在函数调用时就可以输入对应的参数，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(<span class="number">123</span>,<span class="number">13.232</span>);</span><br></pre></td></tr></table></figure><p>在函数定义的函数头中也要写明参数的类型、名称和数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中参数的类型和数量必须和函数原型中的相同，但是函数名称可以不一样</p><h4 id="实际参数与形式参数"><a href="#实际参数与形式参数" class="headerlink" title="实际参数与形式参数"></a>实际参数与形式参数</h4><p>在函数头中定义的两个参数被称为形式参数，属于函数私有</p><p>在函数调用时输入两个参数被称为实际参数，实际参数的值会被赋给形式参数。相当于形式参数是复制了一份的实际参数，然后用于函数运行。</p><p>因此无论在函数中怎么改变形式参数，实际参数的值都不会发生改变。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>出来向函数中传入数据，有时也会希望函数传出一些数据，这时就可以使用返回值</p><h5 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h5><p>在函数定义可以使用return语句来返回数据，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = function(<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数运行到return语句是，就会直接结束函数的运行，会将return后面的表达式的值作为函数的返回值，返回值的类型就是函数的类型。可以看做函数返回值返回后就把函数调用替换成了函数的返回值，即最后一条语句变为，int a = 1 + 1;</p><p>这个示例将完整的函数定义放在了函数调用之前，这样就可以不使用函数原型</p><h4 id="无参数和未指定参数"><a href="#无参数和未指定参数" class="headerlink" title="无参数和未指定参数"></a>无参数和未指定参数</h4><p>使用void可以表明函数没有参数</p><p>如果需要函数接受位置数量的参数，可以使用未指定参数，形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>怎么用以后再学</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明可以看做是函数原型去掉括号里面的东西，可以代替函数原型起到声明函数的作用</p><p>但是因为函数声明并不会指明函数参数的数量和类型，编译器会自动将第一次调用函数时使用的参数数量和类型当做函数的参数数量和类型，如果再调用时使用不同的参数类型或者参数数量不对，就可能会导致错误</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>C运行函数调用它自己，这种调用过程被称为递归（resursion）</p><p>其他以后再写</p><h3 id="编译多源代码文件的程序"><a href="#编译多源代码文件的程序" class="headerlink" title="编译多源代码文件的程序"></a>编译多源代码文件的程序</h3><p>可以使用预处理指令#include 来将其他文件包含到当前文件中，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;const.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>双引号表示被包含的文件位于当前目录中（通常是包含源代码的目录）</p><p>这样就可以将函数定于，一些符号常量的定义等放在其他文件中，在某一个文件专注写程序的主体</p><h1 id="指针初见"><a href="#指针初见" class="headerlink" title="指针初见"></a>指针初见</h1><p>指针（pointer）用于存储变量的地址，是一种值为内存地址的变量</p><h4 id="amp-运算符"><a href="#amp-运算符" class="headerlink" title="&amp;运算符"></a>&amp;运算符</h4><p>&amp;运算符用于查找变量的地址，地址可以看作是变量在内存中的位置</p><h4 id="运算符"><a href="#运算符" class="headerlink" title="*运算符"></a>*运算符</h4><p>*运算符被称为间接运算符或解引用运算符，作用是访问在某个内存地址上的值，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">那么*&amp;a == <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h4 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h4><p>因为不同数据类型占用的储存空间不同，指向这些不同数据类型的指针也有类型，声明某种数据类型的指针时，在数据类型后或变量名之前加*来表明声明的是指向该种数据类型数据的指针，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br></pre></td></tr></table></figure><p>声明了一个指向int类型的指针a</p><h3 id="使用指针在函数间通信"><a href="#使用指针在函数间通信" class="headerlink" title="使用指针在函数间通信"></a>使用指针在函数间通信</h3><p>只使用return语句，一个函数只能返回一个值，如果想在被调函数中改变主调函数中的值，可以用指针，示例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_max</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    find_max(a,b,&amp;max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span>* max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt;= num2)</span><br><span class="line">    &#123;</span><br><span class="line">        *max = num1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *max = num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数的参数中使用指针，就可以将主调函数中的变量的地址作为实际参数，地址被赋给类型为指针的形式参数后，就可以在被调函数中通过对地址上存储的值进行操作来改变主调函数中变量的值</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，一些运算符、循环辅助、分支和跳转</title>
      <link href="/fegnaon.blog/2021/10/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%B8%80%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%BE%AA%E7%8E%AF%E8%BE%85%E5%8A%A9%E3%80%81%E5%88%86%E6%94%AF%E5%92%8C%E8%B7%B3%E8%BD%AC/"/>
      <url>/fegnaon.blog/2021/10/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%B8%80%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%BE%AA%E7%8E%AF%E8%BE%85%E5%8A%A9%E3%80%81%E5%88%86%E6%94%AF%E5%92%8C%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>C语言中以下 3 种逻辑运算符</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与</td></tr><tr><td>||</td><td>或</td></tr><tr><td>！</td><td>非</td></tr></tbody></table><p>&amp;&amp; 为二元运算符，当 &amp;&amp; 左右两侧的运算对象值都为真时，整个逻辑表达式的值为真，若有一个运算对象为假，整个逻辑表达式的值为假</p><p>|| 为二元运算符，当 || 左右两侧的运算对象中有一个为真时，整个逻辑表达式的值为真，若有两个运算对象都为假，整个逻辑表达式的值为假</p><p>! 为一元运算符，运算对象放在其右侧，当运算对象值为真时，整个逻辑表达式的值为假，当运算对象值为假时，整个逻辑表达式的值为真</p><p>比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">2</span>&lt;<span class="number">3</span> 的值为真</span><br><span class="line"><span class="number">9</span>&gt;<span class="number">3</span> || <span class="number">4</span>&lt;<span class="number">2</span>  的值为真</span><br><span class="line">！<span class="number">0</span> 的值为真</span><br></pre></td></tr></table></figure><h4 id="iso646-h-头文件"><a href="#iso646-h-头文件" class="headerlink" title="iso646.h 头文件"></a>iso646.h 头文件</h4><p>如果包含该头文件，可以用 and 作为 &amp;&amp; 的别名，用 or 作为 || 的别名，用 not 作为 ! 的别名</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><table><thead><tr><th>运算符优先级</th><th>结合律</th></tr></thead><tbody><tr><td>（）</td><td>从左往右</td></tr><tr><td>+，-（正负号），++，–，sizeof，强制类型转换运算符，!</td><td>从左往右</td></tr><tr><td>*，/，%</td><td>从左往右</td></tr><tr><td>+，-（加减）</td><td>从左往右</td></tr><tr><td>&lt;，&gt;，&lt;=，&gt;=</td><td>从左到右</td></tr><tr><td>==，!=</td><td>从左到右</td></tr><tr><td>&amp;&amp;</td><td>从左往右</td></tr><tr><td>||</td><td>从左往右</td></tr><tr><td>=</td><td>从右到左</td></tr></tbody></table><h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>逻辑运算符的求值顺序都是从左往右</p><p>&amp;&amp; 和 || 都相当于一个序列点，左侧运算对象的副作用都会在 &amp;&amp; 或 || 处生效，而且一旦发现有使整个表达式为假的因素就立刻停止求值，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a = <span class="number">0</span>) &amp;&amp; (b = <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>a = 0 就已经能够决定整个表达式为假了，就会停止求值，不会在执行 b = 10</p><h3 id="条件运算符：？"><a href="#条件运算符：？" class="headerlink" title="条件运算符：？"></a>条件运算符：？</h3><p>条件运算符 ? 有三个运算对象，是C语言中唯一的三元运算符</p><p>条件运算符的通用形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 ? expression2:expression3</span><br></pre></td></tr></table></figure><p>如果 expression1 值为真，则整个表达式的值为 expression2 的值，若 expression1 的值为假，则整个表达式的值为 expression3 的值</p><p>当需要将两个值中的一个赋给某个变量时，就可以用条件运算符，条件运算符可以更简洁的完成一些 if else 语句的任务</p><h2 id="循环辅助"><a href="#循环辅助" class="headerlink" title="循环辅助"></a>循环辅助</h2><p>一般情况下，每次执行循环体时都会完整的执行一遍循环体，但有的时候只需要执行一部分循环体，就可以使用 continue 和 break 实现</p><p>以下两个语句都可以用于 3 种循环</p><h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>continue 语句的形式： continue;</p><p>使用 continue 语句能直接跳过本次迭代的剩余内容，并开始下一轮循环</p><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>break 语句的形式：break;</p><p>使用 break 语句会终止包含它的那一层循环，并执行循环后面的语句</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="4中分支语句"><a href="#4中分支语句" class="headerlink" title="4中分支语句"></a>4中分支语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>if 语句的通用形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>如果 expression 的值为真，就执行 statement，如果 expression 的值为假，就跳过 statement 执行后面的语句</p><h4 id="else-if-语句"><a href="#else-if-语句" class="headerlink" title="else if 语句"></a>else if 语句</h4><p>else if 语句的通用形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1)</span><br><span class="line">    <span class="function">statement1</span></span><br><span class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(expression2)</span></span></span><br><span class="line"><span class="function">statement2</span></span><br></pre></td></tr></table></figure><p>如果 expression1 为假，就跳过 statement1 ，然后判断 expression2 ，如果 expression2 为真，就执行 statement2 然后退出整个分支语句，否则不执行</p><p>如果 expression1 为真，就执行statement1，然后退出整个分支语句，不会判断 expression2</p><h4 id="else-语句"><a href="#else-语句" class="headerlink" title="else 语句"></a>else 语句</h4><p>else 语句的通用形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1)</span><br><span class="line">    statement1</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure><p>else 与前面的距离它最近的 if 配对</p><p>当 else 上面的所有 expression （包括 if 的和 else if 的）都为假时，就会执行 statement2，然后退出整个分支语句</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>当涉及到多重选择的时候，可以使用 switch 语句，其通用形式如下</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> a : <span class="type">statementa</span></span><br><span class="line">    <span class="keyword">case</span> a : <span class="type">statementb</span></span><br><span class="line">    <span class="keyword">case</span> a : <span class="type">statementc</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    default : <span class="type">statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 expression 的值与 a 相同时，就执行 statementa ， 然后再判断 expression 的值是否与 b 的相同，若相同就只执行 statementb ……一直到所有 case 都判断完，如果一个匹配的 case 都没有，就执行 default 后面的 statement ，如果有至少一个，就不执行 statement</p><h4 id="switch-语句中的-break-语句"><a href="#switch-语句中的-break-语句" class="headerlink" title="switch 语句中的 break 语句"></a>switch 语句中的 break 语句</h4><p>在 switch 语句中的某个 statement 中，可以使用 break 语句来跳出 switch 语句，以免每个 case 都要判断一次</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><h3 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h3><p>goto 语句的通用形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> name;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">... </span><br><span class="line">name: statement</span><br></pre></td></tr></table></figure><p>当程序运行到 goto 时，会直接跳转到 goto 后面的标识符对应的标识符处，中间的语句都不会执行</p><p>标签名可以由字母，数字，下划线组成，但是第一个字符不能是数字</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，一些运算符和循环</title>
      <link href="/fegnaon.blog/2021/10/09/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%B8%80%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%BE%AA%E7%8E%AF/"/>
      <url>/fegnaon.blog/2021/10/09/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%B8%80%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>循环经常以来关系表达式来判断是否进行循环，出现在关系表示中间的运算符叫做关系运算符</p><p>C语言所有的关系运算符</p><table><thead><tr><th>关系运算符</th><th>含义</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于或等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>&gt;=</td><td>大于或等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>!=</td><td>不等于</td></tr></tbody></table><p>关系运算符可以用来比较整数，字符（实际标记的是机器字符码），浮点数，不能用来比较字符串</p><p>但是在比较浮点数时，可能会因为误差导致应该相等的两数并不相等，要尽量只使用&lt;和&gt;</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><table><thead><tr><th>运算符优先级</th><th>结合律</th></tr></thead><tbody><tr><td>（）</td><td>从左往右</td></tr><tr><td>+，-（正负号），++，–，sizeof，强制类型转换运算符</td><td>从左往右</td></tr><tr><td>*，/，%</td><td>从左往右</td></tr><tr><td>+，-（加减）</td><td>从左往右</td></tr><tr><td>&lt;，&gt;，&lt;=，&gt;=</td><td>从左到右</td></tr><tr><td>==，!=</td><td>从左到右</td></tr><tr><td>=</td><td>从右到左</td></tr></tbody></table><h4 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h4><p>当关系表达式为真时，表达式的值为1</p><p>当关系表达式为假时，表达时的值为0。</p><p>除此之外，所有的非零值也都被视为真，比如-2， -20840</p><h4 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h4><p>表示真或假的变量被称为布尔变量，布尔变量的类型名为_Bool</p><p>给_Bool类型的变量赋值时，0会被记为0，其他非零值会被记为1，0代表假false 1代表真true</p><h5 id="stdbool-h头文件"><a href="#stdbool-h头文件" class="headerlink" title="stdbool.h头文件"></a>stdbool.h头文件</h5><p>stdbool.h头文件中让bool成为_Bool的别名，还将true定义为1的符号常量，将false定义为0的符号常量</p><h3 id="其他赋值运算符"><a href="#其他赋值运算符" class="headerlink" title="其他赋值运算符"></a>其他赋值运算符</h3><p>除了=之外，C语言还有其他一些赋值运算符，见下表</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>+=</td><td>相当于将左侧的值加右侧的值的结果赋给左值</td></tr><tr><td>-=</td><td>相当于将左侧的值减右侧的值的结果赋给左值</td></tr><tr><td>/=</td><td>相当于将左侧的值除右侧的值的结果赋给左值</td></tr><tr><td>*=</td><td>相当于将左侧的值乘右侧的值的结果赋给左值</td></tr><tr><td>%=</td><td>相当于将左侧的值对右侧的值取模的结果赋给左值</td></tr></tbody></table><h3 id="逗号运算符-“-”"><a href="#逗号运算符-“-”" class="headerlink" title="逗号运算符 “,”"></a>逗号运算符 “,”</h3><p>逗号运算符常用于for循环，逗号运算符可以将左右两边的表达式连接成一个表达式</p><p>逗号运算符分隔的表达式从左往右求值，逗号运算符相当于一个序列点，左侧项的所有副作用会在执行逗号右侧项之前发生</p><p>整个逗号表达式的值是逗号运算符右侧项的值</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环的通用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>expression为一个表达式，statement为<strong>一个</strong>语句（可以是简单语句也可以大括号括起来的复合语句）（也可以是空语句）</p><p>当程序运行到第一行时，expression的值为真时，就执行statement，执行完之后再检测expression是否为真，若为真再次执行statement一直到某次statement执行之后expression为假，若为假，就执行statement后面的语句</p><p>statement前的缩进不是必须的，但是一般为了看的清楚要使用缩进</p><p>每次循环都被称为一次<strong>迭代</strong></p><p>while循环是使用入口条件的有条件循环，必须满足条件才能进入循环体</p><p>一些while循环是<strong>不确定循环</strong>（在表达式为假之前，不知道要执行多少次循环）</p><p>还有一类循环是<strong>计数循环</strong>，这类循环在执行循环之前就知道要重复执行多少次</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环的通用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (expression1;expression2;expression3)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>在进入循环之前先执行<strong>一次</strong>表达式expression1，然后每次循环之前检测表达式expression2是否为真，若为真就执行语句statement，每次执行完statement之后，就执行一次表达式expression3，然后再次检测表达式expression2是否为真，若为假，就退出循环</p><p>相当于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expression1;</span><br><span class="line"><span class="keyword">while</span>(expression2)</span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">    expressoin3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环也是入口条件循环，除此之外，C语言还有<strong>出口条件循环</strong></p><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h3><p>do while循环的通用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">statement</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(expression)</span></span>;</span><br></pre></td></tr></table></figure><p>在执行时，先执行一次statement，然后检测表达式expression是否为真，若为真就再循环一次，若为假，就退出循环，所以statement无论如何都至少会执行一次</p><p>相当于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">statement</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(expression)</span></span></span><br><span class="line"><span class="function">statment</span></span><br></pre></td></tr></table></figure><p>do while循环是一种<strong>出口条件循环</strong>，即在执行完循环体后才根据测试条件决定是否再次执行循环</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，运算符、表达式和语句</title>
      <link href="/fegnaon.blog/2021/10/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
      <url>/fegnaon.blog/2021/10/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>C语言通过运算符提供各种操作</p><p>运算符有对运算对象的要求，优先级，结合律等特性</p><p>运算对象是值运算符操作的对象，优先级是值不同的运算符的执行顺序，结合律是指连续的同优先级运算符顺序执行的方向</p><p>n元运算符是指有n个运算对象的运算符，比如+是个二元运算符</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符 ="></a>赋值运算符 =</h4><p>在C语言，=并不意味着”相等“，而是一个赋值运算符</p><p>用法：可修改的左值 = 右值 ，“=”会把右值的值赋给可修改的左值</p><p>左值，用于标识特定数据对象（用于储存值的数据存储区域）的名称或表达式，用于标识或定位存储位置的标签</p><p>可修改的左值，用于标识可修改的对象，比如使用了const关键字创建的变量就不是可修改的左值</p><p>右值，是指能赋值给可修改的左值的量，且本身不是左值</p><h4 id="一些基本的算术运算符-，-，-，-，-和-，"><a href="#一些基本的算术运算符-，-，-，-，-和-，" class="headerlink" title="一些基本的算术运算符 +，-，*，/，-和+，()"></a>一些基本的算术运算符 +，-，*，/，-和+，()</h4><p>分别对应数学中的加，减，乘，除，正负号，括号</p><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><p>一元运算符</p><p>sizeof运算符以字节为单位返回运算对象占用的空间的大小，运算对象可以是具体的数据对象，也可以是类型（比如int），如果运算对象是类型的话，需要用()将运算对象括起来</p><h4 id="求模运算符"><a href="#求模运算符" class="headerlink" title="求模运算符 %"></a>求模运算符 %</h4><p>二元运算符</p><p>求模运算符用于整数运算，会给出%左侧的数除以右侧的数的余数，比如11 % 2得到 1</p><p>%左侧的数是正数，求模的结果就是正数</p><p>%左侧的数是负数，求模的结果就是负数</p><h4 id="递增运算符"><a href="#递增运算符" class="headerlink" title="递增运算符 ++"></a>递增运算符 ++</h4><p>一元运算符</p><p>递增运算符可以使其运算对象加1，且有两种方式</p><p>第 1 种，++出现在运算对象的左边，称为前缀模式，会在使用运算对象的值之前使运算对象加1</p><p>第 2 中，++出现在运算对象的右边，称为后缀模式，会在使用运算对象的值之后使运算对象加1</p><h4 id="递减运算符-–"><a href="#递减运算符-–" class="headerlink" title="递减运算符 –"></a>递减运算符 –</h4><p>和递增运算符相似，不过是使运算对象减1</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>上述运算符的优先级见下表，从上到下优先级依次降低</p><table><thead><tr><th>运算符优先级</th><th>结合律</th></tr></thead><tbody><tr><td>（）</td><td>从左往右</td></tr><tr><td>+，-（正负号），++，–，sizeof，强制类型转换运算符</td><td>从左往右</td></tr><tr><td>*，/，%</td><td>从左往右</td></tr><tr><td>+，-（加减）</td><td>从左往右</td></tr><tr><td>=</td><td>从右往左</td></tr></tbody></table><p>对于非连续的分开的同一优先级的运算符，不同的系统会有不同的运算顺序，比如 2*3 + 4*5 中2*3和4*5不一定谁先进行运算</p><h2 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式由运算符和运算对象和子表达式组成</p><p>C语言表达式最重要的特性是，每个表达式都有一个值，普通的运算表达式的值就是运算的结果，有赋值运算符的表达式的值与赋值运算符左侧的值的相同，关系表达式的值不是1就是0，当条件为真时值为1，为假时值为0</p><p>例，表达式3+1的值为4，表达式num = 1+2的值为3，表达式3 &gt; 2的值为1</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句是C程序的基本构建块。</p><p>一条语句相当于一条完整的计算机指令，大部分语句都以分好结尾。</p><p>最简单的语句由一个分号构成（空语句）</p><h4 id="副作用和序列点"><a href="#副作用和序列点" class="headerlink" title="副作用和序列点"></a>副作用和序列点</h4><p>对于C语言来说，表达式的主要目的是得到表达式的值，</p><p>序列点是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生，在C中，语句的分好标记了一个序列点</p><h4 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h4><p>复合语句是用花括号{}括起来的一条或多条语句，复合语句也称为块，整个复合语句被视为一个语句，常用与循环，分支等处</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>在语句和表达式中如果使用的了混合类型，C语言会进行自动类型转换，规则如下</p><p>转换有升级和降级两种，升级就是从较小的类型转换为较大的类型，降级就是从较大的类型转换为较小的类型</p><p>升级时一般不会影响精度，但是降级可能会造成数据失真</p><p>比如将浮点数转换为整数时，小数部分会被截断，将高级的整数转换为低级的整数时，多出的储存空间的数据会被忽略</p><p>数据类型的级别从低到高如下</p><table><thead><tr><th>从上到下依次升高</th></tr></thead><tbody><tr><td>short    char</td></tr><tr><td>int</td></tr><tr><td>unsigned int</td></tr><tr><td>long</td></tr><tr><td>unsigned long</td></tr><tr><td>long long</td></tr><tr><td>unsigned long long</td></tr><tr><td>float</td></tr><tr><td>double</td></tr><tr><td>long double</td></tr></tbody></table><ol><li><p>  将一种类型的值赋给另一种类型的变量时，会将=右侧的值转换为左侧的数据类型的值</p></li><li><p>在含有不同类型数据的混合运算中，会将较低级类型的数据升级为表达式中最高级的类型的数据，每进行一步才进行一次转换</p><p>   比如3/5*22.0会从左往右先算3/5为0，然后算0*22.0为0，不会一下全部转换为double</p></li><li><p>  在表达式中，short和char无论如何都会被先转换为int</p></li><li><p>  在表达式中，float无论如何都会被先转换为double</p></li></ol><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>当需要精确的进行类型转换的时候，可以使用强制类型转化，通过强制类型转换运算符来完成</p><p>强制类型转换运算符的形式为 (类型名) ，比如(int)</p><p>强制类型转换运算符会将后面的一个数据转换为指定的数据类型</p><h2 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h2><p>在函数头 类型名 函数名（变量声明1，变量声明2 ……）,中可以声明参数，声明参数会创建被称为形式参数（简称形参）的变量，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br></pre></td></tr></table></figure><p>就创建了一个名为number的形参，在调用函数的时候使用的参数，其值会被传递给number，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">function(a);</span><br></pre></td></tr></table></figure><p>就是将a的值10传递给函数，这值被赋给形参number，函数调用时传递的值被称为实际参数</p><p>当实际参数的数据类型与形式参数的数据类型不匹配时，会自动进行类型转换</p><h4 id="函数声明和函数原型"><a href="#函数声明和函数原型" class="headerlink" title="函数声明和函数原型"></a>函数声明和函数原型</h4><p>函数声明值只指明函数名和返回类型，函数原型还会指明参数的类型</p><p>如果没有指明参数的类型的话，程序会将第一次调用函数时传入的参数的类型当做该函数的参数类型</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校课程</title>
      <link href="/fegnaon.blog/2021/10/06/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"/>
      <url>/fegnaon.blog/2021/10/06/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h1><h5 id="平时成绩-30"><a href="#平时成绩-30" class="headerlink" title="平时成绩 30%"></a>平时成绩 30%</h5><p>​    云班课随堂测试（8次） 5%</p><p>​    慕课单元检测题 120min2次，去高分 5%</p><p>​    平时作业+纸质单元检测 20%</p><h5 id="期中考试-20"><a href="#期中考试-20" class="headerlink" title="期中考试 20%"></a>期中考试 20%</h5><h5 id="期末考试-50"><a href="#期末考试-50" class="headerlink" title="期末考试 50%"></a>期末考试 50%</h5><h1 id="程序设计与算法"><a href="#程序设计与算法" class="headerlink" title="程序设计与算法"></a>程序设计与算法</h1><h5 id="慕课成绩-10"><a href="#慕课成绩-10" class="headerlink" title="慕课成绩 10%"></a>慕课成绩 10%</h5><p>​    视频单元考核 3%</p><p>​    作业单元考核7%</p><p>​    2021年12月20日前完成</p><h5 id="icoding平台编程实验-40"><a href="#icoding平台编程实验-40" class="headerlink" title="icoding平台编程实验 40%"></a>icoding平台编程实验 40%</h5><p>​    实验一 2021年10月25日截止</p><p>​    实验二2021年11月15日截止</p><p>​    实验三2021年11月22日截止</p><p>​    实验四2021年12月13日截止</p><p>​    实验五2021年12月20日截止</p><p>​    实验六2022年1月03日截止</p><p>具体截止时间均为当日23:55</p><h5 id="期末考试-50-1"><a href="#期末考试-50-1" class="headerlink" title="期末考试 50%"></a>期末考试 50%</h5><h1 id="通用英语B（彭焱老师的班）"><a href="#通用英语B（彭焱老师的班）" class="headerlink" title="通用英语B（彭焱老师的班）"></a>通用英语B（彭焱老师的班）</h1><h5 id="课堂教学-36"><a href="#课堂教学-36" class="headerlink" title="课堂教学 36%"></a>课堂教学 36%</h5><p>​    课堂任务 9%</p><p>​        个人课堂表现，非常规的课堂任务</p><p>​    小组作品（最少两次单元项目） 9%</p><p>​    基础测验（随堂单元测验） 9%</p><p>​    主题写作（批改网/教室评阅） 9%</p><h5 id="在线慕课（课程实验）-9"><a href="#在线慕课（课程实验）-9" class="headerlink" title="在线慕课（课程实验） 9%"></a>在线慕课（课程实验） 9%</h5><p>​    单元测验 3.6%</p><p>​        第一单元 2021年9月30日截止</p><p>​        </p><p>​    作业 3.6%</p><p>​        </p><p>​    讨论1.8%</p><p>​        在”课堂讨论“模块中回复超过8个数量的帖子</p><h5 id="口语实践（口语坊或随堂测试）-6"><a href="#口语实践（口语坊或随堂测试）-6" class="headerlink" title="口语实践（口语坊或随堂测试） 6%"></a>口语实践（口语坊或随堂测试） 6%</h5><h5 id="听力实训（U校园听力）-9"><a href="#听力实训（U校园听力）-9" class="headerlink" title="听力实训（U校园听力） 9%"></a>听力实训（U校园听力） 9%</h5><p>​    在线完成时间 2.7%</p><p>​        9小时</p><p>​    答题正确率 6.3%</p><p>​        Unit1 2021年9月26日截止</p><p>​        Unit2 2021年10月31日截止</p><p>​        Unit3 2021年11月21日截止</p><p>​        Unit4 2021年12月5日截止</p><p>​        Unit5 2021年12月19日截止</p><p>​        Unit6 2022年1月02日截止</p><h5 id="期末考试-40"><a href="#期末考试-40" class="headerlink" title="期末考试 40%"></a>期末考试 40%</h5><h1 id="线性代数与空间解析几何"><a href="#线性代数与空间解析几何" class="headerlink" title="线性代数与空间解析几何"></a>线性代数与空间解析几何</h1><h5 id="平时成绩-30-1"><a href="#平时成绩-30-1" class="headerlink" title="平时成绩 30%"></a>平时成绩 30%</h5><p>​    作业</p><p>​        讲到哪做到哪，每周四交作业</p><p>​    mooc测试</p><p>​        第一章单元检测题 2021年10月31日截止</p><p>​        第二章单元检测题 2021年11月21日截止</p><h5 id="期中考试-20-1"><a href="#期中考试-20-1" class="headerlink" title="期中考试 20%"></a>期中考试 20%</h5><h5 id="期末考试-50-2"><a href="#期末考试-50-2" class="headerlink" title="期末考试 50%"></a>期末考试 50%</h5><h1 id="中国近代史纲要"><a href="#中国近代史纲要" class="headerlink" title="中国近代史纲要"></a>中国近代史纲要</h1><p>云班课</p><h1 id="计算机思维导论"><a href="#计算机思维导论" class="headerlink" title="计算机思维导论"></a>计算机思维导论</h1><p>作业</p><h1 id="军事理论"><a href="#军事理论" class="headerlink" title="军事理论"></a>军事理论</h1><p>网课</p><h1 id="体育"><a href="#体育" class="headerlink" title="体育"></a>体育</h1><p>课外锻炼    36次</p><p>跑步 50km</p><h1 id="心理健康与创新能力"><a href="#心理健康与创新能力" class="headerlink" title="心理健康与创新能力"></a>心理健康与创新能力</h1><p>慕课单元测验2021年12月28日截止</p><p>慕课需要在课堂交流区讨论，有效回复老师发起的每个讨论贴，且总共加起来被赞数达到10个，可获得本部分成绩的满分</p><p><img src="https://i.loli.net/2021/10/06/GxVPpLjzqug1by7.gif" alt="cat"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习，字符串和格式化输入/输出</title>
      <link href="/fegnaon.blog/2021/10/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"/>
      <url>/fegnaon.blog/2021/10/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是一个或多个字符的序列，由双引号来表示，如 “Hello , World!” 就是一个字符串</p><p>C语言没有专门用于储存字符串的变量，字符串都被储存在char类型的数组中</p><p>|</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是同类型数据元素的有序序列，由连续的储存单元组成</p><h5 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">40</span>];</span><br></pre></td></tr></table></figure><p>char表示每个元素的类型，name是数组的名字，方括号[]表示这是一个数组，40表示数组占用的字节数</p><p>|</p><p>字符串中除了字符本身，在字符串的最后还有一个非打印字符空字符’\0’来表示字符串的结束，C语言中的字符串一定以空字符结尾</p><p>ps:字符串”s”和字符’s’并不一样，字符串”s”实际上是由’s’和’\0’两个字符组成的</p><h4 id="strlen-函数和sizeof-函数"><a href="#strlen-函数和sizeof-函数" class="headerlink" title="strlen()函数和sizeof()函数"></a>strlen()函数和sizeof()函数</h4><p>sizeof()函数会以字节为单位返回参数的存储空间大小，即使某些储存空间没有字符，他们也会被算在内</p><p>strlen()函数会以字节为单位返回参数除’\0’之前的字符占用的存储空间的大小</p><p>两个函数的返回值类型均为size_t</p><p>ps:不同语言的文字的字符占用的空间的大小会因语言和编码不同而改变，比如utf-8中的一个汉字占3个字节</p><p>比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>] = “王大炮”;</span><br><span class="line"><span class="keyword">sizeof</span>(name);                    -&gt;<span class="number">20</span></span><br><span class="line"><span class="built_in">strlen</span>(name);                    -&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="常量和C预处理器"><a href="#常量和C预处理器" class="headerlink" title="常量和C预处理器"></a>常量和C预处理器</h2><p>常量除了直接用他们本身表示之外，还可以使用符号常量</p><h4 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ol><li><p>  声明一个变量，使之等于某个常量</p></li><li><p>用预处理器来定义常量，0</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZERO 0</span></span><br></pre></td></tr></table></figure><p>  这样可以防止ZERO的值改变，通常用大写表示符号常量，或在名称前面加c_或 k_</p></li><li><p>使用 const 关键字</p><p>  在声明变量时在变量类型前面加上 const 可以来限定一个变量为只读的，该变量的值就无法被改变，如</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>  能表达的信息更多，常量名通常可以表达比数字更多的信息，如0.98和 G </li><li>  更改常量值的时候只需要在定义常量名的地方改一次，不用每个地方都做改动</li></ol><h5 id="limits-h和float-h"><a href="#limits-h和float-h" class="headerlink" title="limits.h和float.h"></a>limits.h和float.h</h5><p>这两个头文件中，分别定义了一些整数类型和浮点数类型的大小限制相关的常量</p><p>比如CHAR_MAX , INT_MAX , ULONG_MIN或FLT_MAX , DBL_DIG等</p><h2 id="printf-和scanf"><a href="#printf-和scanf" class="headerlink" title="printf()和scanf()"></a>printf()和scanf()</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h3><p>printf()的格式为printf(格式化字符串，参数1，参数2……);</p><p>格式化字符串由实际要打印的字符串和转换说明组成，转换说明会按照一定方式被替换</p><h4 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h4><p>转换说明用百分号%来表示，格式转换说明符有如下几种</p><table><thead><tr><th>转换说明</th><th>输出</th></tr></thead><tbody><tr><td>%a</td><td>浮点数、十六进制数和p计数法</td></tr><tr><td>%A</td><td>浮点数、十六进制数和p计数法</td></tr><tr><td>%c</td><td>单个字符</td></tr><tr><td>%d</td><td>有符号十进制整数</td></tr><tr><td>%e</td><td>e记法十进制浮点数，e为小写</td></tr><tr><td>%E</td><td>e加法十进制浮点数，e为大写</td></tr><tr><td>%f</td><td>十进制浮点数</td></tr><tr><td>%g</td><td>根据值的不同，自动选择%f或%e</td></tr><tr><td>%G</td><td>根据值的不同，自动选择%f或%E</td></tr><tr><td>%i</td><td>有符号十进制整数</td></tr><tr><td>%o</td><td>无符号八进制整数</td></tr><tr><td>%p</td><td>指针</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%u</td><td>无符号十进制整数</td></tr><tr><td>%x</td><td>无符号十六进制整数，字母为小写</td></tr><tr><td>%X</td><td>无符号十六进制整数，字母为大写</td></tr><tr><td>%%</td><td>一个百分号%</td></tr></tbody></table><p>除了%%外，转换说明会依次与格式化字符串后面的参数一一对应，并且转换说明一定要和后面的参数想匹配，不然就会出错</p><h5 id="转换说明修饰符"><a href="#转换说明修饰符" class="headerlink" title="转换说明修饰符"></a>转换说明修饰符</h5><p>在百分号%和转换说明字符之间，还可以插入转换说明修饰符来修饰转换说明，格式转换说明修饰符有如下几种</p><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td>标记</td><td>标记见下一个表格，可以同时使用多个标记</td></tr><tr><td>数字</td><td>最小字段宽度，输出的字段不会比数字中的值小，如果该字段宽度不能容纳要打印的内容，系统会增加宽度</td></tr><tr><td></td><td>如果最小字段宽度比要打印的内容大，默认用空格填充，并且空格加在左边</td></tr><tr><td>.数字</td><td>精度</td></tr><tr><td></td><td>对于%e,%E和%f,表示小数点右边数字的位数</td></tr><tr><td></td><td>对于%g和%G，表示有效数字的最大位数</td></tr><tr><td></td><td>对于%s，表示待打印字符的最大数量</td></tr><tr><td></td><td>对于整数，表示待打印数字的最小位数</td></tr><tr><td></td><td>如果位数不够，会用0来填充，0填充在左边</td></tr><tr><td></td><td>只用一个 . 而不加数字表示 .0</td></tr><tr><td>h</td><td>和整形转换说明一起使用，表示short类型，如%hi , %hu</td></tr><tr><td>hh</td><td>和整形转换说明一起使用，表示char或unsigned char类型</td></tr><tr><td>j</td><td>和整形转换说明一起使用，表示intmax_t或uintmax_t类型，这是stdint.h中的类型</td></tr><tr><td>l</td><td>和整形转换说明一起使用，表示long或unsigned long类型</td></tr><tr><td>ll</td><td>和整形转换说明一起使用，表示long或unsigned long long类型</td></tr><tr><td>L</td><td>和浮点转换说明一起使用，表示long double类型</td></tr><tr><td>t</td><td>和整形转换说明一起使用，表示ptrdiff_t类型，ptrdiff_t是两个指针差值的类型</td></tr><tr><td>z</td><td>和整形转换说明一起使用，表示size_t类型，size_t是sizeof()和strlen()返回的类型</td></tr></tbody></table><p>除此之外，还有一个特殊的*修饰符</p><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>可以代替前一个表中的数字，并在读取后面对于的参数来作为这个数字</td></tr></tbody></table><p>在printf()中，float类型的值会被自动转换为double类型，所有float和double都可以用%f</p><p>标记有如下五种</p><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>要打印的内容左对齐</td></tr><tr><td>+</td><td>若值为正，在值前打印+，若值为负，在值前打印-</td></tr><tr><td>空格</td><td>若值为正，在前面显示空格，若值为负，在之前显示-并覆盖空格</td></tr><tr><td>#</td><td>转化结果形式</td></tr><tr><td></td><td>对于%o , 在值前加上0</td></tr><tr><td></td><td>对于%x或%X , 在值前0x或0X</td></tr><tr><td></td><td>对于所有浮点格式，即时后面没有数字，也会打印一个小数点.</td></tr><tr><td>0</td><td>用0代替空格来填充字段宽度</td></tr><tr><td></td><td>对于整数，若出现-或指定精度，则忽略该标记</td></tr></tbody></table><h5 id="转换说明的意义"><a href="#转换说明的意义" class="headerlink" title="转换说明的意义"></a>转换说明的意义</h5><p>转换说明表示如何将计算机中储存的二进制数据转换为字符串，包括读取多大的储存空间，如何读取，如何转换等</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>printf()会返回打印字符的个数，如果输出错误，会返回一个负值。一般很少会用到，但在检查输出错误时可能会用到</p><h4 id="打印较长的字符串"><a href="#打印较长的字符串" class="headerlink" title="打印较长的字符串"></a>打印较长的字符串</h4><p>打印较长的字符串有3种方法</p><ol><li>  使用多个printf()语句</li><li>  在一行的最后加上\表示字符串还没有结束，会从下一行继续(包括下一行开头可能有的空格)</li><li>  使用多个” “,比如”hello” “world”会被自动合并成”helloworld”，中间的空格会被合并</li></ol><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h3><p>scanf()的格式为scanf(格式化字符串，参数1，参数2……);</p><p>与printf()不同，scanf的参数要使用指向变量的指针</p><p>对于基本变量类型的值，要在变量名前加上一个&amp;</p><p>对于数组类型的值，不要加&amp;</p><h5 id="格式转换说明"><a href="#格式转换说明" class="headerlink" title="格式转换说明"></a>格式转换说明</h5><table><thead><tr><th>转换说明</th><th>含义</th></tr></thead><tbody><tr><td>%c</td><td>把输入解释为单个字符</td></tr><tr><td>%d</td><td>把输入解释为有符号十进制整数</td></tr><tr><td>%e %f %g %a</td><td>把输入解释为浮点数</td></tr><tr><td>%E %F %G %A</td><td>把输入解释为浮点数</td></tr><tr><td>%i</td><td>把输入解释为有符号十进制整数</td></tr><tr><td>%o</td><td>把输入解释为有符号八进制整数</td></tr><tr><td>%p</td><td>把输入解释为指针</td></tr><tr><td>%s</td><td>把输入解释为字符串</td></tr><tr><td>%u</td><td>把输入解释为无符号十进制整数</td></tr><tr><td>%x %X</td><td>把输入解释为有符号十六进制整数</td></tr></tbody></table><h5 id="格式转换修饰"><a href="#格式转换修饰" class="headerlink" title="格式转换修饰"></a>格式转换修饰</h5><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>抑制赋值，只读取，但读到值不会赋给任何变量</td></tr><tr><td>数字</td><td>最大字段宽度，输入达到最大字段宽度时，停止读取</td></tr><tr><td>hh</td><td>把整数作为signed char或unsigned char类型读取</td></tr><tr><td>ll</td><td>把整数作为long long或unsigned long long类型读取</td></tr><tr><td>h</td><td>把整数作为short或unsigned short类型读取</td></tr><tr><td>l</td><td>把整数作为long或unsigned long类型读取</td></tr><tr><td></td><td>或把浮点数作为double类型读取</td></tr><tr><td>L</td><td>把浮点作为long double类型读取</td></tr><tr><td>j</td><td>表示使用intmax_t类型或uintmax_t类型</td></tr><tr><td>z</td><td>表示使用size_t类型</td></tr><tr><td>t</td><td>表示使用表示两个指针差值的类型</td></tr></tbody></table><p>在scanf()中，float类型要用%f，double类型要用%lf，不能够混用</p><h4 id="scanf-如何读取输入"><a href="#scanf-如何读取输入" class="headerlink" title="scanf()如何读取输入"></a>scanf()如何读取输入</h4><p>scanf()会从输入的第一个匹配的字符开始读取，比如%d会从一个数字或者正负号开始读取，到不匹配的字符或空白字符结束</p><p>空白字符是指 空格、回车和tab</p><p>使用最大字段宽度时，读取到最大字段款到时就会结束</p><p>读取完一个参数后，会从上一次读取结束的地方开始读取下一个参数</p><p>对于%c，会读取任何一个字符，包括空白字符</p><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>scanf()函数会返回成功读取的项数</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习,整数和浮点数</title>
      <link href="/fegnaon.blog/2021/10/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
      <url>/fegnaon.blog/2021/10/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h4 id="整数的类型"><a href="#整数的类型" class="headerlink" title="整数的类型"></a>整数的类型</h4><p>​        C语言中，整数有 _Bool , char , short , int , long , long long  他们之间的区别在于占用的储存空间不同</p><h5 id="不同整数类型占用的储存空间"><a href="#不同整数类型占用的储存空间" class="headerlink" title="不同整数类型占用的储存空间"></a>不同整数类型占用的储存空间</h5><p>​        char 一定是占一个字节的位数，至少且一般为8位</p><p>​        C标准值规定了char &lt;= short &lt;= int &lt;= long &lt;= long long 具体大小由编译器决定</p><p>​        short至少占16位，long至少占32位，long long至少占64位</p><h5 id="不同整数类型能表示的整数的范围"><a href="#不同整数类型能表示的整数的范围" class="headerlink" title="不同整数类型能表示的整数的范围"></a>不同整数类型能表示的整数的范围</h5><p>​        各数据类型能表示的整数的范围由其占用的储存空间和是否带符号决定</p><p>​                带符号的情况下，因为计算机通过补码的方式表示正负数，若n为位数，则一个整数能表达的整数范围为 -2^(n-1)~2^(n-1)-1</p><p>​                        比如 带符号的 char 能表示的整数范围为 -128~127</p><p>​                不带符号的情况的，若n为位数，则一个整数能表达的整数范围为 0~2^n-1</p><p>​                        比如 不带符号的 char 能表示的整数范围为 0~255</p><p>​        如何表示一个整数带不带符号使用</p><p>​                对于 char 类型的整数，默认情况下带不带符号C标准没有规定，由使用的编译器决定</p><p>​                对于其他类型的整数，都是带符号的</p><p>​                使用unsigned关键能表示一个整数是不带符号，比如 unsigned char 一定是一个不带符号的char类型整数</p><p>​                使用signed关键字也可以强调一个整数是带符号的</p><h5 id="整数的声明"><a href="#整数的声明" class="headerlink" title="整数的声明"></a>整数的声明</h5><p>​        使用 整数类型关键 + 空格 + 变量名 可以声明一个整数，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure><p>就声明一个类型为int名为x的变量</p><p>​        声明short类型的整数时，整数类型关键字可以写成short int也可以吧int省略，long和long long类型的整数同理</p><p>​        在一行中可以声明多个变量，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,z;</span><br></pre></td></tr></table></figure><p>声明的多个变量之间要用”,”隔开</p><p>​        声明时也可以直接为变量赋值，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>就表示声明一个类型为int名为x的变量，并为x变量赋为10</p><p>​        在一行中声明多个变量时也可以为变量赋值，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,z = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>表示声明三个类型为int的变量，并将z变量赋值10（并不会给x和y赋值），想给那个变量赋值就在哪个变量后面写=，但一般情况下最好不要混着写。</p><h5 id="整数的赋值"><a href="#整数的赋值" class="headerlink" title="整数的赋值"></a>整数的赋值</h5><p>​        赋值</p><p>​                为整数变量赋值时，默认情况下是赋给变量十进制的数，比如 x = 10;后x等于十进制下的10；</p><p>​        也可以赋给变量八进制或者十六进制的数，在数字前加“0”表示八进制，加“0x”表示十六进制，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">012</span>;</span><br><span class="line">y = <span class="number">0x12</span>;</span><br></pre></td></tr></table></figure><p>​        表示x等于十进制下的10，y等于十进制下的18</p><h5 id="储存字符"><a href="#储存字符" class="headerlink" title="储存字符"></a>储存字符</h5><p>​        char类型常用语储存字符，char类型可以通过储存某个字符对应的ascii码来存储对应的字符</p><p>​        在赋值时也可以直接将一个字符常量赋给整数变量（在C语言中，使用单括号括起来的单个字符被称为字符常量），编译器将其转换为对应的ascii码。</p><p>​        打印时，使用%c可以对应ascii码对应的字符，使用%d可以打印存的数的十进制形式。</p><h4 id="可移植类型"><a href="#可移植类型" class="headerlink" title="可移植类型"></a>可移植类型</h4><h5 id="stdint-h"><a href="#stdint-h" class="headerlink" title="stdint.h"></a>stdint.h</h5><p>​        在stdint.h头文件中，有更多的类型名</p><p>​        精确宽度整数类型，如int32_t表示32位的有符号整数类型，</p><p>​        但某个系统对某个宽度可能并不支持，可以用 最小宽度类型，如int_least8_t表示可容纳8位有符号整数值的类型中宽度最小的类型</p><p>​        除此之外，还有intmax_t，int_fast8_t，uintmax_t等</p><h5 id="inttypes-h"><a href="#inttypes-h" class="headerlink" title="inttypes.h"></a>inttypes.h</h5><p>​        inttype.h头文件中包含了一些表示转换说明的宏，如RPId32表示32位的有符号整数</p><h5 id="整数常量的储存方式"><a href="#整数常量的储存方式" class="headerlink" title="整数常量的储存方式"></a>整数常量的储存方式</h5><p>​        通常，十进制整数常量会被储存为int类型，如果大于int类型的范围，会依次使用long和long long</p><p>​        对于八进制或十六进制的整数常量，会依次储存为int , unsigned int , long , unsigned long , long long , unsigned long long类型</p><p>​        如果需要指定储存方式，可以在数字后加上u或U表示unsigned，加上l或L表示long ,比如23uLL,32LU</p><h5 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h5><p>​        _Bool类型表示布尔值，用1表示true,用0表示false</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h4 id="浮点数的类型"><a href="#浮点数的类型" class="headerlink" title="浮点数的类型"></a>浮点数的类型</h4><p>​        浮点有float , double , long double三种</p><h5 id="不同浮点数类型占用的储存空间"><a href="#不同浮点数类型占用的储存空间" class="headerlink" title="不同浮点数类型占用的储存空间"></a>不同浮点数类型占用的储存空间</h5><p>​        float占32位，double占64位，long double大于等于double</p><h5 id="不同浮点数类型能表示的浮点数的范围"><a href="#不同浮点数类型能表示的浮点数的范围" class="headerlink" title="不同浮点数类型能表示的浮点数的范围"></a>不同浮点数类型能表示的浮点数的范围</h5><p>​        浮点数在计算机由符号，小数，指数三部分组成</p><p>​        float指数能表示6位有效数字，且取值范围至少是10^(-37)~10^37</p><p>​        double至少能表示10位有效数字，且取值范围至少和float相同</p><p>​        long double的精度至少比double的高</p><h5 id="浮点数的声明"><a href="#浮点数的声明" class="headerlink" title="浮点数的声明"></a>浮点数的声明</h5><p>​        基本和整数的相同，且浮点数赋值时可以用e记法的数</p><h5 id="浮点型常量"><a href="#浮点型常量" class="headerlink" title="浮点型常量"></a>浮点型常量</h5><p>​        浮点型常量的基本形式是，有符号的带小数点的数字 + e或E + 表示指数的有符号的数字</p><p>​        其中，正号可以省略，小数点和指数可以省略其一，小数部分和整数部分可以省略其一</p><p>​        默认情况下，浮点型常量是double类型</p><p>​        同样，在数字后加上f或F，l或L来表示具体的类型，如3.2F ， 32E3L</p><h5 id="浮点值的上溢和下溢"><a href="#浮点值的上溢和下溢" class="headerlink" title="浮点值的上溢和下溢"></a>浮点值的上溢和下溢</h5><p>​        当一个浮点数超过当前类型能表达的最大范围是，就会上溢，这时，该变量会被赋一个表示无穷大的inf或infinity</p><p>​        当一个浮点数的指数部分是最小值的，再减小时会将小数点向左以，小数点部分的最后的一位数会被丢弃</p><h5 id="浮点数的精度"><a href="#浮点数的精度" class="headerlink" title="浮点数的精度"></a>浮点数的精度</h5><p>​        由于计算机中不能表示无穷多的数字</p><p>​        能存储的数字实际上是离散的，因此浮点数的储存，计算等也是存在误差的，在判断浮点数计算的结果的时，可以用增加一个允许的误差范围来得到想要的结果</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习,2</title>
      <link href="/fegnaon.blog/2021/10/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-2/"/>
      <url>/fegnaon.blog/2021/10/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-2/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>C程序示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>                   <span class="comment">/*一个简单的C程序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a simple &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;computer.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My favortie number is %d because it is first .\n num&quot;</span>,num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>#include &lt;stdio.h&gt;</p></blockquote><p>该行作用相当于把stdio.h文件中的所有内容都输入该行所在的位置</p><p>#include 是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即<em>预处理</em></p><p>stdio.h文件提供了输入输出函数(如printf())</p><p>通常，C程序顶部的信息集合被称为<em>头文件</em></p><blockquote><p>int main()</p></blockquote><p>C程序一定从main()函数开始执行，（）用于识别main是一个函数</p><blockquote><p>/* 一个简单的C程序 */</p></blockquote><p>注释，被/* 和 */ 包住的部分是程序的注释，能让人更容易明白所写的程序，注释会被编译器忽略</p><p>使用// 可以将某一行注释</p><blockquote><p>{}</p></blockquote><p>所有的C函数都使用花括号标记函数体的开始和结束</p><p>花括号还可以用于把函数中的多条语句合并为一个单元或块</p><blockquote><p>int num;</p></blockquote><p>这行代码叫做声明。该声明完成了两件事，一在函数中有一个名为num的变量，二int表明num变量是一个整数，编译器使用这些信息为num变量在内存中分配空间</p><p>int是C语言的一个<em>关键字</em>，表示一种基本的C语言数据类型。关键字是语言定义的单词，不能做其他用途。</p><p>num是一个<em>标识符</em>（一个变量、函数名或其他实体的名称)</p><p>​    变量可以用大小写字母数字下划线（_）来命名，而且名称的第一个字符必须是字母或者下划线，不能是数字</p><p>在C语言中，所有变量都必须先声明才能使用</p><blockquote><p>num = 1;</p></blockquote><p>这行代码是<em>赋值表达式语句</em>，会从右侧把值赋到左侧</p><blockquote><pre><code>printf(&quot;I am a simple &quot;);printf(&quot;computer.\n&quot;);printf(&quot;My favortie number is %d because it is first .\n num&quot;,num);</code></pre></blockquote><p>printf()是C语言的一个标准函数，（）表示printf是一个函数名，（）中的信息被称为参数，从main()函数传递给printf()函数。</p><p>更确切的说，是函数的实际参数。</p><p>​    在C语言中，实际参数是传递给函数的特定值，形式参数是函数中用于储存值的变量</p><p>\n的意思的换行，换行符是一个<em>转义序列</em>，转义序列用于表达难以表示或无法输入的字符</p><p>%d相当于是一个占位符，用来知名输出num的位置</p><blockquote><p>return 0；</p></blockquote><p>用于返回main()函数的返回值</p><h5 id="多条声明"><a href="#多条声明" class="headerlink" title="多条声明"></a>多条声明</h5><p>一条声明中可以声明多个变量，如int a,b;等价与int a; int b;</p><h5 id="加入函数"><a href="#加入函数" class="headerlink" title="加入函数"></a>加入函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> hanshu(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">hanshu</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行为<em>函数原型</em>，也被称为<em>函数原型</em>，指明了函数的属性（返回值类型，函数名，参数数量和类型）</p><p>倒数第四行和往后为函数定义，即是函数本身的源代码</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习,1</title>
      <link href="/fegnaon.blog/2021/10/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/fegnaon.blog/2021/10/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<h5 id="C语言优点"><a href="#C语言优点" class="headerlink" title="C语言优点"></a>C语言优点</h5><p> 1.设计特性</p><p>2.高效性</p><p>​        C语言具有微调控制能力，可以根据具体情况微调程序已获最大运行速度或最有效地使用内存</p><p>3.可移植性</p><p>​        C是可移植的语言，在一种系统中编写的C程序稍作修改或者不修改就可以在其他系统运行。（针对特殊硬件设备或操作系统特殊功能编写的部分桐城市不可移植的）</p><p>4.强大而灵活</p><p>5.面向程序员</p><h5 id="编程的7个步骤"><a href="#编程的7个步骤" class="headerlink" title="编程的7个步骤"></a>编程的7个步骤</h5><p>1.定义程序的目标</p><p>​        明确自己想做什么，程序需要哪些信息，需要进行哪些计算和控制，以及程序应该要报告什么信息。</p><p>2.设计程序</p><p>​        考虑如何用程序完成目标。如何组织程序，准备用多久完成程序，目标用户是谁…..</p><p>3.编写代码</p><p>4.编译</p><p>5.运行程序</p><p>6.测试和调试程序</p><p>7.维护和修改代码</p><h5 id="编译机制"><a href="#编译机制" class="headerlink" title="编译机制"></a>编译机制</h5><p>把源代码文件转换为可执行文件。典型的C实现通过编译和链接2个步骤来完成这一过程。</p><p>编译器把源代码转换为中间代码，链接器把中间代码和其他代码合并，生成可执行文件</p><p>中间文件有多种形式，最普遍的一种：把源代码转换为机器语言代码，并把结果放在目标文件中(还不是一个完整的程序)</p><p>目标文件缺少启动代码，启动代码充当程序和操作系统之间的接口</p><p>目标文件还缺少库函数</p><p>链接器将以上三者合并成一个文件。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21年10月4日</title>
      <link href="/fegnaon.blog/2021/10/04/21%E5%B9%B410%E6%9C%884%E6%97%A5%E8%AE%B0/"/>
      <url>/fegnaon.blog/2021/10/04/21%E5%B9%B410%E6%9C%884%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>​        今天做了个并查集的招新题。</p><p>​        一开始不知道啥是并查集，也没搜，就直接开始硬做，最后字符串数组强行弄出来一个，但是数据稍微一多就不行了。学oi的舍友回宿舍一看题，说并查集呀。我一搜，恍然大悟，发现自己真是个猪鼻</p><p>​        以后要开始做点算法题惹</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/fegnaon.blog/2021/10/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/fegnaon.blog/2021/10/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>人生中写的第一篇博客，主要就回顾反思一下前18年，和对未来的一些想法吧</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="出生—2021-6-10"><a href="#出生—2021-6-10" class="headerlink" title="出生—2021.6.10"></a>出生—2021.6.10</h3><p>​        从出生到高考结束，在计算机方面，大概就是个山东三线小城的普通孩子，只是会用电脑来打打游戏逛逛网页，对编程最深入的了解是为了通过小中考在信息课上学的visual basic(现在已经完全不记得当时学过啥…)。高中阶段也没接触过竞赛，也没有什么目标，只想着先尽量考高一点再说，就普普通通的度过的高中阶段，期间也没有怎么很努力过，高考前还天天拿平板在课上看小说（）。</p><h3 id="2021-6-10—2021-9-6"><a href="#2021-6-10—2021-9-6" class="headerlink" title="2021.6.10—2021.9.6"></a>2021.6.10—2021.9.6</h3><p>​        填报志愿时，因为没有喜欢也没有不喜欢的…，就准备选热门的软工或计科，出分前准备冲一冲哈尔滨工业大学(威海)的软件工程或山东大学(威海)的计算机，出分之后直接人品爆炸超常发挥从平常的省一万四五千名直接冲到省4000名，然后选来选去就把成电放在稳上的第一位。也不知道这个选的对不对，但既然来了，就要认真对待了。</p><p>​        9月6号第一天上课之前，每天就是玩玩玩，完全没有预习，不过在这期间也通过水群了解到成电有好多工作室，工作室里好多和厉害的人，而且进工作室不太容易…就准备从开始的上课的第一天开始，努力肝进工作室。</p><h3 id="2021-9-6—2021-10-3"><a href="#2021-9-6—2021-10-3" class="headerlink" title="2021.9.6—2021.10.3"></a>2021.9.6—2021.10.3</h3><p>​         第一个月怎么学的，学的啥现在已经不太能回想起来了，为了记录好自己的学习历程以便回顾复习，也因为招新题要求，从今天开始我要开始充实我的博客，记录一下每天的学习、解决的问题之类的。</p><p>​        第一个月我大概就是在b站看了看翁恺的C语言，做了一些招新题…好像也没干别的了…也不知道为啥这一个月过的这么快…</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>​        以后会尽力充实自己的博客，多写笔记多做记录，不让自己一头雾水吧</p><p>​        做招新题的时候我发现很多时候只是勉强完成了题目，达到的题目的要求，但对于写下的代码，和背后的原理，并没有很好的理解掌握。在招新笔试结束之前的这最后几天，还是会以完成招新题为第一目标，在这之后，我目前的想法是扎扎实实的打好基础(比如把《C primer plus》啃完)。</p><p>​        希望能进去起码一个工作室吧…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
